<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#3367D6"/>
  <link rel="apple-touch-icon" href="/icons-192.png">
  <link rel="manifest" href="/manifest.json">
  
  <meta name="generator" content="Hexo 5.4.0">

  

  

  
    <meta name="author" content="sterne">
  

  

  

  <title>软件工程复习 | Welcome -Sterne&#39;s Blog-</title>

  

  
    <link rel="shortcut icon" href="/favicon.ico">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@1.1.3/index.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/monokai.css">
  

  
<link rel="stylesheet" href="/css/style.css">

<link rel="alternate" href="/atom.xml" title="Welcome -Sterne's Blog-" type="application/atom+xml">
</head>
<body>
  <div class="root-container">
    
<!-- header container -->
<header class="header-container post">
  
    <div class="post-image" style="background-image: url(/img/cover.jpg)"></div>
  

  <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          Welcome -Sterne&#39;s Blog-
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">Home</a></li>
        
          <li class="navbar-list-item"><a href="/links">Links</a></li>
        
          <li class="navbar-list-item"><a href="/about">About</a></li>
        
      </ul>
    </div>
  </div>
</nav>

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-text layout-block">
        <div class="layout-margin">
          <h1 class="title-wrap">软件工程复习</h1>
          <h2 class="title-sub-wrap">
            <strong>sterne</strong>
            <span>发布于</span>
            <time  class="article-date" datetime="2022-05-18T11:43:31.000Z" itemprop="datePublished">2022-05-18</time>
          </h2>
          <ul class="wrap-list dark">
  
</ul>
          <ul class="wrap-list dark">
  
    <li><a href="/tags/review/">🏷️ review</a></li>
  
</ul>
        </div>
      </div>
    </div>
  

  
  
  
</header>

    <!-- 文章 -->

<!-- 文章内容 -->
<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
      
      
      
      
      <section class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box">
        <h1 id="Part1-软件工程概述"><a href="#Part1-软件工程概述" class="headerlink" title="Part1.软件工程概述"></a>Part1.软件工程概述</h1><h2 id="1-软件与软件工程的概念"><a href="#1-软件与软件工程的概念" class="headerlink" title="1.软件与软件工程的概念"></a>1.软件与软件工程的概念</h2><h3 id="1-1软件的概念、特性和分类"><a href="#1-1软件的概念、特性和分类" class="headerlink" title="1.1软件的概念、特性和分类"></a>1.1软件的概念、特性和分类</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>•软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合。</p>
<p>•程序是按事先设计的功能和性能要求执行的指令序列。</p>
<p>•数据是使程序能正常操纵信息的数据结构。</p>
<p>•文档是与程序开发，维护和使用有关的图文材料。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>(1) 形态特性: 软件是无形的、不可见的逻辑实体。度量常规产品的几何尺寸、物理性质和化学成分对它却是毫无意义的。 </p>
<p>(2) 智能特性：软件是复杂的智力产品，它的开发凝聚了人们的大量脑力劳动，它本身也体现了知识实践经验和人类的智慧，具有一定的智能。它可以帮助我们解决复杂的计算、分析、判断和决策问题。</p>
<p>(3) 开发特性: 尽管已经有了一些工具（也是软件）来辅助软件开发工作，但到目前为止尚未实现自动化。软件开发中仍然包含了相当份量的个体劳动，使得这一大规模知识型工作充满了个人行为和个人因素。</p>
<p>(4) 质量特性：目前还无法得到完全没有缺陷的软件产品 。</p>
<p>(5) 生产特性:与硬件或传统的制造业产品的生产完全不同，软件一旦设计开发出来，如果需要提供多个用户，它的复制十分简单，其成本也极为有限 。 </p>
<p>(6) 管理特性：由于上述的几个特点，使得软件的开发管理显得更为重要，也更为独特 。</p>
<p>(7) 环境特性:软件的开发和运行都离不开相关的计算机系统环境，包括支持它的开发和运行的相关硬件和软件。软件对于计算机系统的环境有着不可摆脱的依赖性。 </p>
<p>(8) 维护特性：软件投入使用以后需要进行维护，但这种维护与传统产业产品的维护概念有着很大差别。</p>
<p>(9) 废弃特性: 与硬件不同，软件并不是由于被“用坏”而被废弃的 。</p>
<p>(10) 应用特性：软件的应用极为广泛，如今它已渗入国民经济和国防的各个领域，现已成为信息产业、先进制造业和现代服务业的核心，占据了无可取代的地位。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>（1） 系统软件</p>
<p>•操作系统•数据库管理系统•设备驱动程序•通信和网络处理程序等 </p>
<p>（2）支撑软件（工具软件）</p>
<p>•纵向支撑软件：分析、设计、编码、测试工具等•横向支撑软件：项目管理工具，配置管理工具等</p>
<p>（3）应用软件</p>
<p>•工程与科学计算软件•商业数据处理软件•ERP软件•计算机辅助设计／制造软件•系统仿真软件•智能产品嵌入软件•事务管理、办公自动化软件</p>
<p>（4）可复用软件</p>
<p>•标准函数库、类库、构件库等</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>具有产品和产品生产载体的双重作用。</p>
<p>(1)作为产品，软件显示了由计算机硬件体现的计算能力，扮演着信息转换的角色：产生、管理、查询、修改、显示或者传递各种不同的信息。</p>
<p>(2)作为产品生产的载体，软件提供了计算机控制（操作系统）、信息通信（网络），以及应用程序开发和控制的基础平台（软件工具和环境）。 </p>
<h4 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h4><p>不同类型、不同应用领域、不同用户对软件质量要素的要求也有很大差别。从事办公和机要工作的软件对安全性要求比较高。实时嵌入式软件对正确性和可靠性要求比较高等等。软件开发过程必须根据软件的实际情况对软件质量要素的定位进行折衷和决策。</p>
<p>下面给出软件工程常用的八个质量要素的定义和解释。</p>
<p>(1)正确性(correctness)。</p>
<p> 软件满足需求规约及完成用户目标的程度。</p>
<p>(2)可用性(usability)。</p>
<p>学习和使用软件的难易程度，包括：操作软件、为软件准备输入数据，解释软件输出结果等。学习和使用困难的软件可用性差，符合人们习惯、传统的软件可用性好。</p>
<p>(3)可靠性(reliability)。</p>
<p>软件完成预期功能，成功运行的概率。软件可靠性反映了软件无故障工作的状况。为了提高可靠性必须提高软件开发、测试、维护的质量，减少软件潜伏的缺陷数量。对于实时嵌入式计算机系统，软件要实时地控制一个物理过程，如果可靠性得不到保证，一旦出现问题可能是灾难性的，后果不堪设想。</p>
<p>(4)有效性(efficiency)。</p>
<p>软件系统利用计算机的时间资源和空间资源完成系统功能的能力。各种计算机软件无不将系统的时／空开销和网络环境下的信息传输开销作为衡量软件质量的一项重要技术指标。很多场合，在追求时间有效性和空间有效性方面会发生矛盾，这时不得不牺牲时间效率换取空间有效性，或牺牲空间效率换取时间有效性。时／空折衷是经常出现的。有经验的软件设计人员会巧妙地利用折衷概念，在具体的物理环境中实现用户的需求和自己的设计。</p>
<p>(5)可维护性(maintainability)。</p>
<p>软件制品交付用户使用后，能够对它进行修改，以便改正潜伏的缺陷、改进性能和其他属性，使软件制品适应环境的变化等等。由于软件是逻辑产品，只要用户需要可以无限期地使用下去，软件维护是不可避免的。软件维护成本约占整个生命周期的40%至60%。软件维护费用高的问题今天仍然没有明显改变。</p>
<p>(6)可移植性(portability)。</p>
<p>将软件安装在不同计算机系统或环境的难易程度。为了获得比较高的可移植性，在软件设计过程中通常采用通用的程序设计语言和运行支撑环境。对依赖于计算机系统的低级(物理)特征部分，如编译系统的目标代码生成，应相对独立、集中。这样与处理机无关的部分就可以移植到其他系统上使用。</p>
<p>(7)安全性(security)。</p>
<p>控制或保护程序和数据不受破坏的机制，以防止程序和数据受到意外的或蓄意的存取、使用、修改、毁坏或泄密。在网络环境下计算机犯罪、恶作剧增多，软件安全受到人们的高度重视。软件的安全性已成为用户十分关心的质量要素，影响着软件开发、测试、维护各个方面。</p>
<p>(8)可复用性(reusebility)。</p>
<p>概念或功能相对独立的一个或一组相关模块定义为一个软构件。软构件可以在多种场合应用的程度称为构件的可复用性。可复用的软构件有的可以不加修改直接使用，有的需要修改才可使用。可复用软构件应具有清晰的结构和注解，应具有正确的编码和较低的时/空开销。各种可复用软构件还可以按照某种规则存放在软构件库中，供软件工程师们选用。可复用性有助于提高软件制品的质量和开发效率、有助于降低软件的开发和维护费用。</p>
<h3 id="1-2软件危机与软件工程"><a href="#1-2软件危机与软件工程" class="headerlink" title="1.2软件危机与软件工程"></a>1.2软件危机与软件工程</h3><p>软件危机暴发于上个世纪六十年代末。</p>
<p>主要表现为：软件的发展速度远远滞后于硬件的发展速度，不能满足社会日益增长的软件需求。软件开发周期长、成本高、质量差、维护困难。</p>
<p>原因：</p>
<p>缺乏软件开发的经验和有关软件开发数据的积累，使得开发工作的计划很难制定。</p>
<p>软件人员与用户的交流存在障碍，使得获取的需求不充分或存在错误 。</p>
<p>软件开发过程不规范。如，没有真正了解用户的需求就开始编程序。</p>
<p>随着软件规模的增大，其复杂性往往会呈指数级升高。需要很多人分工协作，不仅涉及技术问题，更重要的是必须有科学严格的管理。</p>
<p>缺少有效的软件评测手段，提交用户的软件质量不能完全保证。   </p>
<p>解决：</p>
<p>彻底消除“软件就是程序”的错误观念。</p>
<p>充分认识到软件开发应该是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目。</p>
<p>推广和使用在实践中总结出来的开发软件的成功技术、方法和工具。</p>
<p>按工程化的原则和方法组织软件开发工作。</p>
<p>软件工程概念的提出：</p>
<p>在NATO会议上，Fritz Bauer对软件工程的定义是：“软件工程就是为了经济地获得可靠的且能在实际机器上有效地运行的软件，而建立和使用完善的工程原理。”</p>
<p>1993年IEEE给出的定义：“软件工程是：① 把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件；② 研究①中提到的途径。”。</p>
<p>•概括地说，软件工程是指导计算机软件开发和维护的工程学科。<br> 采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p>
<h3 id="1-3软件工程的目标"><a href="#1-3软件工程的目标" class="headerlink" title="1.3软件工程的目标"></a>1.3软件工程的目标</h3><p>软件工程的目标是运用先进的软件开发技术和管理方法来提高软件的质量和生产率，也就是要以较短的周期、较低的成本生产出高质量的软件产品，并最终实现软件的工业化生产。 </p>
<p> 付出较低的开发成本</p>
<p> 达到要求的软件功能</p>
<p> 取得较好的软件性能</p>
<p> 开发的软件易于移植</p>
<p> 需要较低的维护费用</p>
<p> 能按时完成开发工作，及时交付使用</p>
<img src="/2022/05/18/software/image-20220603095340882.png" class="" title="image-20220603095340882">

<h3 id="1-4软件生存期"><a href="#1-4软件生存期" class="headerlink" title="1.4软件生存期"></a>1.4软件生存期</h3><p>软件也有一个孕育、诞生、成长、成熟和衰亡的生存过程，我们称这个过程为软件生命周期或软件生存期。</p>
<p>软件生存期分为三个时期</p>
<h4 id="软件定义"><a href="#软件定义" class="headerlink" title="软件定义"></a>软件定义</h4><p>问题定义：关键问题是：“要解决的问题是什么”。提交的内容为关于问题性质、工程目标和工程规模的书面报告。</p>
<p>可行性研究：回答的关键问题是：“上一个阶段所确定的问题是否有行得通的解决办法”。提交的内容为可行性研究报告，即从技术、经济和社会因素等方面研究各方案的可行性</p>
<p>需求分析：对用户提出的要求进行分析并给出详细的定义</p>
<p>准确地回答“目标系统必须做什么”这个问题。也就是对目标系统提出完整、准确、清晰、具体的要求。</p>
<p>编写软件需求说明书或系统功能说明书及初步的系统用户手册</p>
<p>提交管理机构评审</p>
<h4 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h4><p>任务：具体设计和实现前一个时期即软件定义时期定义的软件。</p>
<p>执行人：系统设计员，高级程序员，程序员，测试工程师和辅助人员等</p>
<p>阶段划分：分为概要设计、详细设计、编码和单元测试、集成测试和系统测试。其中前两个阶段又称为系统设计，后两个阶段又称为系统实现。</p>
<h5 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h5><p>概括地回答“怎样实现目标系统?”。</p>
<p>设计程序的体系结构，也就是确定程序由哪些模块组成以及模块间的关系。</p>
<p>提交的文档是概要设计说明书。</p>
<h5 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h5><p>回答“应该怎样具体地实现这个系统”。</p>
<p>详细地设计每个模块，确定实现模块功能所需要的算法和数据结构。</p>
<p>提交的文档是软件的详细设计说明书。</p>
<h5 id="程序编码和单元测试"><a href="#程序编码和单元测试" class="headerlink" title="程序编码和单元测试"></a>程序编码和单元测试</h5><p>写出正确的容易理解、容易维护的程序模块。</p>
<p>提交的文档为源程序、详尽的程序说明和单元测试报告。</p>
<h5 id="集成测试和系统测试"><a href="#集成测试和系统测试" class="headerlink" title="集成测试和系统测试"></a>集成测试和系统测试</h5><p>通过各种类型的测试(及相应的调试)使软件达到预定的要求。（黑盒白盒测试等）</p>
<p>提交的文档为测试计划、详细测试方案以及实际测试结果等。</p>
<h4 id="运行维护"><a href="#运行维护" class="headerlink" title="运行维护"></a>运行维护</h4><p>改正性维护，也就是诊断和改正在使用过程中发现的软件错误；</p>
<p>适应性维护，即修改软件以适应环境的变化；</p>
<p>完善性维护，即根据用户的要求改进或扩充软件，使它更完善；</p>
<p>预防性维护，即修改软件为将来的维护活动预先做准备。</p>
<h3 id="1-5软件工程方法概述"><a href="#1-5软件工程方法概述" class="headerlink" title="1.5软件工程方法概述"></a>1.5软件工程方法概述</h3><p>软件工程包含技术和管理两方面的内容，是技术和管理紧密结合所形成的工程学科。</p>
<p>通常将软件开发全过程中使用的一整套技术方法的集合称为方法学(methedology)，也称为范型(paradigm)。</p>
<p>目前使用最广泛的软件工程方法学：传统方法学（<strong>结构化方法学</strong>），<strong>面向对象方法学</strong>。</p>
<h4 id="三要素：方法、工具和过程。"><a href="#三要素：方法、工具和过程。" class="headerlink" title="三要素：方法、工具和过程。"></a>三要素：方法、工具和过程。</h4><p>软件工程方法为软件开发提供了 “如何做” 的技术;</p>
<p>软件工具为软件工程方法提供了自动的或半自动的软件支撑环境;</p>
<p>过程是为了获得高质量的软件所需要完成的一系列任务框架，它规定了完成各项任务的工作步骤。</p>
<h3 id="1-6软件工具概述"><a href="#1-6软件工具概述" class="headerlink" title="1.6软件工具概述"></a>1.6软件工具概述</h3><p>软件工具的概念</p>
<p>软件工具是指能支持软件生存周期中某一阶段（如系统定义、需求分析、设计、编码、测试或维护等）的需要而使用的软件工具。</p>
<p>早期的软件工具主要用来辅助程序员编程，如编辑程序、编译程序、排错程序等。</p>
<p>软件工具的分类：支持软件开发过程的工具、支持软件维护过程的工具、支持软件管理过程和支持过程的工具</p>
<h3 id="1-7软件工程知识体系及知识域"><a href="#1-7软件工程知识体系及知识域" class="headerlink" title="1.7软件工程知识体系及知识域"></a>1.7软件工程知识体系及知识域</h3><p>似乎不太重要</p>
<h2 id="2-软件生存期模型"><a href="#2-软件生存期模型" class="headerlink" title="2.软件生存期模型"></a>2.软件生存期模型</h2><h3 id="2-1瀑布模型"><a href="#2-1瀑布模型" class="headerlink" title="2.1瀑布模型"></a>2.1瀑布模型</h3><img src="/2022/05/18/software/image-20220603101635795.png" class="" title="image-20220603101635795">

<p>瀑布模型(waterfall model)也称软件生存周期模型，是W.Royce在1970年首先提出的。</p>
<p>瀑布模型将软件开发过程分解为<strong>可行性研究、软件需求、设计、编码、测试、运行与维护、退役</strong>。</p>
<p>它们既是软件开发过程的分解，也是软件生存周期的阶段划分。</p>
<p>瀑布模型按照各阶段的目标和任务逐步进行开发，直至通过确认测试，向用户交付最终软件制品为止。</p>
<p>面对较大的复杂系统，人们细化了瀑布模型的阶段或过程划分，如下图所示。</p>
<img src="/2022/05/18/software/image-20220603101810065.png" class="" title="image-20220603101810065">

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>阶段间具有顺序性和依赖性。其中包含两重含义：</p>
<p>① 必须等前一阶段的工作完成之后，才能开始后一阶段的工作；</p>
<p>② 前一阶段的输出文档就是后一阶段的输入文档。</p>
<p>推迟实现的观点</p>
<p>① 瀑布模型在编码之前设置了系统分析和系统设计的各个阶段，分析与设计阶段的基本任务规定，在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的物理实现。</p>
<p>② 清楚地区分逻辑设计与物理设计，尽可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要的指导思想</p>
<p>质量保证的观点</p>
<p>① 每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。</p>
<p>② 每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误。</p>
<p>实际的瀑布模型</p>
<p>实际的瀑布模型是带“反馈环”的，如图所示。实现代表开发过程，虚线代表维护过程。</p>
<img src="/2022/05/18/software/image-20220603101930531.png" class="" title="image-20220603101930531">

<p>•V模型：瀑布模型的一个变体</p>
<p>V模型描述了测试阶段的活动与开发阶段相关活动（包括需求建模、概要设计、详细设计、编码）之间的关系。</p>
<img src="/2022/05/18/software/image-20220603102002610.png" class="" title="image-20220603102002610">

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>可强迫开发人员采用规范化的方法。</p>
<p>严格地规定了每个阶段必须提交的文档。</p>
<p>要求每个阶段交出的所有产品都必须是经过验证的。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要。如果需求规格说明与用户需求之间有差异，就会发生这种情况。</p>
<p>瀑布模型只适用于项目开始时需求已确定的情况。（需求不确定→不适合）</p>
<h3 id="2-2快速原型模型"><a href="#2-2快速原型模型" class="headerlink" title="2.2快速原型模型"></a>2.2快速原型模型</h3><p>快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。</p>
<img src="/2022/05/18/software/image-20220603102113100.png" class="" title="image-20220603102113100">

<p>原型有两类。</p>
<img src="/2022/05/18/software/image-20220603102257320.png" class="" title="image-20220603102257320">

<p>(1)抛弃型原型(实验性原型)</p>
<p> 利用原型定义和确认了软件需求后，原型就完成了任务。</p>
<p> 开发人员就可以按照确认的需求进行软件设计、编码、测试。</p>
<p>(2)应用型原型(进化性原型)</p>
<p> 利用原型确认软件需求后，对原型进一步加工、完善，使之成为系统的一部分。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>(1)有助于满足用户的真实需求。</p>
<p>(2)原型系统已经通过与用户的交互而得到验证，据此产生的规格说明文档能够正确地描述用户需求。</p>
<p>(3)软件产品的开发基本上是按线性顺序进行。</p>
<p>(4)因为规格说明文档正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发现规格说明文档的错误而进行较大的返工。</p>
<p>(5)开发人员通过建立原型系统已经学到了许多东西，因此，在设计和编码阶段发生错误的可能性也比较小，这自然减少了在后续阶段需要改正前面阶段所犯错误的可能性。</p>
<p>(6) 快速原型的突出特点是“快速”。开发人员应该尽可能快地建造出原型系统，以加速软件开发过程，节约软件开发成本。原型的用途是获知用户的真正需求，一旦需求确定了，原型可以抛弃，当然也可以在原型的基础上进行开发。</p>
<h3 id="2-3增量模型"><a href="#2-3增量模型" class="headerlink" title="2.3增量模型"></a>2.3增量模型</h3><img src="/2022/05/18/software/image-20220603102515586.png" class="" title="image-20220603102515586">

<p>使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。</p>
<p>每个构件由多个相互作用的模块构成，并且能够完成特定的功能。</p>
<p>每个增量构件应当实现某种系统功能，因此增量构件的开发可以采用瀑布模型的方式</p>
<img src="/2022/05/18/software/image-20220603102620177.png" class="" title="image-20220603102620177">

<p>采用增量模型需注意的问题 </p>
<p>(1)在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。</p>
<p>(2)软件体系结构必须是开放的，即向现有产品中加入新构件的过程必须简单、方便。</p>
<p> 因此，采用增量模型比采用瀑布模型和快速原型模型更需要精心的设计。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>(1)能在较短时间内向用户提交可完成一些有用的工作产品，即从第1个构件交付之日起，用户就能做一些有用的工作。</p>
<p>(2)逐步增加产品的功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给用户组织带来的冲击。</p>
<p>(3)项目失败的风险较低，虽然在某些增量构件中可能遇到一些问题，但其他增量构件将能够成功地交付给客户。</p>
<p>(4)优先级最高的服务首先交付，然后再将其他增量构件逐次集成进来。因此，最重要的系统服务将接受最多的测试。 </p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="2-4螺旋模型"><a href="#2-4螺旋模型" class="headerlink" title="2.4螺旋模型"></a>2.4螺旋模型</h3><p>采用增量模型需注意的问题 </p>
<p>(1)在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。</p>
<p>(2)软件体系结构必须是开放的，即向现有产品中加入新构件的过程必须简单、方便。</p>
<p> 因此，采用增量模型比采用瀑布模型和快速原型模型更需要精心的设计。</p>
<p>理解这种模型的一个简便方法，是把它看做在每个阶段之前都增加了风险分析过程的快速原型模型。 </p>
<img src="/2022/05/18/software/image-20220603102736394.png" class="" title="image-20220603102736394">

<img src="/2022/05/18/software/image-20220603102750586.png" class="" title="image-20220603102750586">

<h4 id="完整的螺旋模型"><a href="#完整的螺旋模型" class="headerlink" title="完整的螺旋模型"></a>完整的螺旋模型</h4><p>在螺旋模型中，软件过程表示成一个螺线，而不是像以往的模型那样表示为一个具有回溯的活动序列。</p>
<p>在螺线上的每一个循环表示过程的一个阶段。</p>
<p>每个阶段开始时的任务是确定该阶段的目标、为完成这些目标选择方案及设定这些方案的约束条件。接下来的任务是，从风险角度分析上一步的工作结果，努力排除各种潜在的风险，通常用建造原型的方法来排除风险。如果成功地排除了所有风险，则启动下一步开发步骤，在这个步骤的工作过程相当于纯粹的瀑布模型。最后是评价该阶段的工作成果并计划下一个阶段的工作。</p>
<p>螺旋模型适合大型软件开发，特别是目前应用广泛的电子商务、电子政务一类的业务软件系统。</p>
<p>开发这类系统时，软件需求往往不能完全确定。</p>
<p>项目开始时开发人员与用户协商，将能够确定的需求、暂时不能确定的需求划分为一系列的增量，并为增量排序，确定的、急需的增量排在前面，暂时不能确定或不急需的放在后面。</p>
<p>采用螺旋模型开发这类软件具有边学习、边建模，边开发、边使用、边改进的优点。</p>
<h4 id="螺旋模型的4项活动"><a href="#螺旋模型的4项活动" class="headerlink" title="螺旋模型的4项活动"></a>螺旋模型的4项活动</h4><p>螺线上的每一个循环可划分为4个象限，分别表达了4个方面的活动。</p>
<p>(1)目标设定——定义在该阶段的目标，弄清对过程和产品的限制条件，制订详细的管理计划，识别项目风险，可能还要计划与这些风险有关的对策。</p>
<p>(2)风险估计与弱化——针对每一个风险进行详细分析，设想弱化风险的步骤。</p>
<p>(3)开发与验证——评价风险之后选择系统开发模型。</p>
<p>(4)计划——评价开发工作，确定是否继续进行螺线的下一个循环。如果确定要继续，则计划项目的下一个阶段的工作</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标。</p>
<p>减少了过多测试或测试不足所带来的风险。</p>
<p>在螺旋模型中维护只是模型的另一个周期，因而在维护和开发之间并没有本质区别。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>螺旋模型是风险驱动的，因此要求软件开发人员必须具有丰富的风险评估经验和这方面的专门知识，否则将出现真正的风险：当项目实际上正在走向灾难时，开发人员可能还以为一切正常。</p>
<h3 id="2-5喷泉模型"><a href="#2-5喷泉模型" class="headerlink" title="2.5喷泉模型"></a>2.5喷泉模型</h3><img src="/2022/05/18/software/image-20220603103357522.png" class="" title="image-20220603103357522">

<p>喷泉模型是典型的面向对象生命周期模型。</p>
<p>“喷泉”一词体现了迭代和无间隙特性。图中代表不同阶段的圆圈相互重叠，这明确表示两个活动之间存在重叠。用面向对象方法开发软件时，在分析、设计和编码等项开发活动之间不存在明显的边界，而各阶段在表示方法上的一致性也保证了各项开发活动之间的无缝过度。途中一个阶段内的向下箭头代表该阶段中的迭代或求精。</p>
<h3 id="2-6统一过程"><a href="#2-6统一过程" class="headerlink" title="2.6统一过程"></a>2.6统一过程</h3><img src="/2022/05/18/software/image-20220603103602073.png" class="" title="image-20220603103602073">



<h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h4><p>在统一过程中，有6个核心工作流。</p>
<p>① 业务建模工作流。用商业用例为商业过程建立文档。</p>
<p>② 需求工作流。目标是描述系统应该做什么，确保开发人员构建正确的系统。为此，需明确系统的功能需求和非功能需求（约束）。</p>
<p>③ 分析和设计工作流。其目标是说明如何做。结果是分析模型和设计模型。</p>
<p>④ 实现工作流。用分层的方式组织代码的结构，用构件的形式来实现类，对构件进行单元测试，将构件集成到可执行的系统中。</p>
<p>⑤ 测试工作流。验证对象之间的交互、是否所有的构件都集成了、是否正确实现了所有需求、查错并改正。</p>
<p>⑥ 部署工作流。制作软件的外部版本、软件打包、分发、为用户提供帮助和支持。</p>
<h4 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h4><p>统一过程有4个阶段，分别是初始阶段、细化阶段、构造阶段和移交阶段。</p>
<p>① 初始阶段。初始阶段主要关注项目计划和风险评估，其目的是确定是否值得开发目标信息系统。</p>
<p>② 细化阶段。细化阶段关心定义系统的总体框架，其目标是：细化初始需求（用况）、细化体系结构、监控风险并细化它们的优先级、细化业务案例以及制订项目管理计划。</p>
<p>③ 构造阶段。构造阶段是建立系统，构造信息系统的第1个具有操作质量的版本，以能够交付给客户进行b测试的版本结束，有时称为测试版本。</p>
<p>④ 移交阶段。移交阶段包含b测试时期，以发布完整的系统而终止，其目标是确保信息系统真正满足客户的需求。</p>
<img src="/2022/05/18/software/image-20220603103733823.png" class="" title="image-20220603103733823">

<h3 id="2-7基于构件的开发模型"><a href="#2-7基于构件的开发模型" class="headerlink" title="2.7基于构件的开发模型"></a>2.7基于构件的开发模型</h3><p>强调使用可复用的软件“构件”来设计和构造基于计算机的系统的过程。</p>
<p>考虑的焦点是集成，而不是实现。</p>
<img src="/2022/05/18/software/image-20220603103810050.png" class="" title="image-20220603103810050">

<p>不考虑构件的开发技术，基于构件的开发模型由以下步骤组成：</p>
<p>(1)对于该问题领域的基于构件的可用产品进行研究和评估。</p>
<p>(2)考虑构件集成的问题。</p>
<p>(3)设计软件架构以容纳这些构件。</p>
<p>(4)将构件集成到架构中。</p>
<p>(5)进行充分的测试以保证功能正常。</p>
<h3 id="2-8敏捷过程"><a href="#2-8敏捷过程" class="headerlink" title="2.8敏捷过程"></a>2.8敏捷过程</h3><p>2001年，Kent Beck等17名编程大师发表“敏捷软件开发”宣言：</p>
<p> 我们正在通过亲身实践以及帮助他人实践的方式来揭示更好的软件开发之路，通过这项工作，我们认为：</p>
<p>   个体和交互胜过过程和工具；</p>
<p>   可工作软件胜过宽泛的文档；</p>
<p>   客户合作胜过合同谈判；</p>
<p>   响应变化胜过遵循计划。 </p>
<p>任何一个敏捷过程都可以由所强调的3个关键假设识别出来，这3个假设可适用于大多数软件项目。</p>
<p>(1) 提前预测哪些需求是稳定的、哪些需求会变化非常困难。同样的，预测项目进行中客户优先级的变化也很困难。</p>
<p>(2) 对很多软件，设计和构建是交错进行的。事实上，两种活动应当顺序开展以保证通过构建实施来验证设计模型，而在通过构建验证之前很难估计应该设计到什么程度。</p>
<p>(3) 从制订计划的角度来看，分析、设计、构建和测试并不像我们所设想的那么容易预测。</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>(1)我们最优先要做的是通过尽早、持续交付有价值的软件来使客户满意。</p>
<p>(2)即使在开发的后期，也欢迎需求变更。敏捷过程利用变更为客户创造竞争优势。</p>
<p>(3)经常交付可运行软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。</p>
<p>(4)在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。 </p>
<p>(5)围绕有积极性的个人构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作。</p>
<p>(6)在团队内部，最富有效果和效率的信息传递方法是面对面交谈。</p>
<p>(7)可运行软件是进度的首要度量标准。</p>
<p>(8)敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一种长期、稳定的开发速度。</p>
<p>(9)不断地关注优秀的技能和好的设计会增强敏捷能力。</p>
<p>(10)简单是必要的。</p>
<p>(11)好的架构、需求和设计出自于自组织团队。</p>
<p>(12)每隔一定时间，团队会反省如何才能更有效地工作，并相应调整自己的行为</p>
<h4 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h4><p>敏捷软件开发过程适合小型一般软件的开发</p>
<p>适合建造原型系统</p>
<p>适合开发需求不确定的易变的业务处理系统</p>
<p>适合负责任的专业用户能加入开发团队并一直在开发现场工作的软件项目（多数场合，这一点是困难的）。</p>
<p>用敏捷软件开发过程快速构建原型，进行人机界面设计将是十分有效的。</p>
<p>生命攸关的实时系统，如空中交通指挥控制系统，机载、弹载、星载、船载的导航和武器控制系统的关键软件采用敏捷软件开发过程是不适宜的。这些软件需求定义严格、开发责任分明、必须有严格的测试和标准的文档，对安全性和保密性有更严格的规定。</p>
<h4 id="极限编程（eXtreme-Programming，XP）"><a href="#极限编程（eXtreme-Programming，XP）" class="headerlink" title="极限编程（eXtreme Programming，XP）"></a>极限编程（eXtreme Programming，XP）</h4><p>使用最广泛的敏捷过程，最初由Kent Beck提出。XP包含了策划、设计、编码和测试4个框架活动的规则和实践。 </p>
<img src="/2022/05/18/software/image-20220603105423453.png" class="" title="image-20220603105423453">

<h4 id="自适应软件开发"><a href="#自适应软件开发" class="headerlink" title="自适应软件开发"></a>自适应软件开发</h4><p>自适应软件开发（adaptive software development，ASD）是由Jim Highsmith提出的；</p>
<p>它可作为构建复杂软件和系统的一项技术，其基本概念着眼于人员合作和团队自组织。</p>
<img src="/2022/05/18/software/image-20220603105603747.png" class="" title="image-20220603105603747">

<h1 id="Part2-结构化分析与设计方法"><a href="#Part2-结构化分析与设计方法" class="headerlink" title="Part2.结构化分析与设计方法"></a>Part2.结构化分析与设计方法</h1><h2 id="3-软件需求获取与结构化分析方法"><a href="#3-软件需求获取与结构化分析方法" class="headerlink" title="3.软件需求获取与结构化分析方法"></a>3.软件需求获取与结构化分析方法</h2><h3 id="3-1需求获取与需求分析阶段的任务"><a href="#3-1需求获取与需求分析阶段的任务" class="headerlink" title="3.1需求获取与需求分析阶段的任务"></a>3.1需求获取与需求分析阶段的任务</h3><p>需求获取的主要任务是与客户或用户沟通，了解系统或产品的目标是什么？客户或用户想要实现什么？系统和产品如何满足业务的要求，最终系统或产品如何用于日常工作？</p>
<p>获取并理解用户的需求是软件工程师所面对的最困难的任务之一。</p>
<p>导出需求变得如此困难的原因归为以下几个方面的问题：</p>
<p>系统的目标或范围问题；</p>
<p>需求不准确性问题 ；</p>
<p>需求的易变问题 ；</p>
<p>需求获取除了需要有专业的系统分析师，还需要通过有效的客户／开发者的合作才能成功。 </p>
<h4 id="1-需求获取的任务和原则"><a href="#1-需求获取的任务和原则" class="headerlink" title="1.需求获取的任务和原则"></a>1.需求获取的任务和原则</h4><p>需求获取的任务</p>
<p>(1) 发现和分析问题，并分析问题的原因/结果关系。</p>
<p>(2) 与用户进行各种方式的交流，并使用调查研究方法收集信息。</p>
<p>(3) 按照三个成分观察问题的不同侧面：即数据、过程和接口。</p>
<p>(4) 将获取的需求文档化，形式有用例、决策表、需求表等。</p>
<p>需求获取应遵循的原则</p>
<p>(1) 深入浅出的原则。就是说，需求获取要尽可能全面、细致。获取的需求是个全集，目标系统真正实现的是个子集。</p>
<p>(2) 以流程为主线的原则。在与用户交流的过程中，应该用流程将所有的内容串起来。如信息、组织结构、处理规则等。这样便于交流沟通。流程的描述既有宏观描述，也有微观描述。</p>
<h4 id="2-需求获取的过程"><a href="#2-需求获取的过程" class="headerlink" title="2.需求获取的过程"></a>2.需求获取的过程</h4><h5 id="开发高层的业务模型"><a href="#开发高层的业务模型" class="headerlink" title="开发高层的业务模型"></a>开发高层的业务模型</h5><h5 id="定义项目范围和高层需求"><a href="#定义项目范围和高层需求" class="headerlink" title="定义项目范围和高层需求"></a>定义项目范围和高层需求</h5><h5 id="识别用户类和用户代表"><a href="#识别用户类和用户代表" class="headerlink" title="识别用户类和用户代表"></a>识别用户类和用户代表</h5><p>系统的不同用户之间在很多方面存在差异，例如：</p>
<p>(1) 使用产品的频率；</p>
<p>(2) 用户在应用领域的经验和使用计算机系统的技能；</p>
<p>(3) 所用到的产品功能；</p>
<p>(4) 为支持业务过程所进行的工作；</p>
<p>(5) 访问权限和安全级别</p>
<h5 id="获取具体的需求"><a href="#获取具体的需求" class="headerlink" title="获取具体的需求"></a>获取具体的需求</h5><p>  确定了项目范围和高层需求，并确定了用户类及用户代表后，就需要获取更具体、完整和详细的需求。具体需求的来源可以来自以下几种典型的途径。</p>
<p> (1) 与用户进行交流。 </p>
<p> (2) 现有产品或竞争产品的描述文档。  </p>
<p> (3) 系统需求规格说明。</p>
<p> (4) 当前系统的问题报告和改进要求。</p>
<p> (5) 市场调查和用户问卷调查。</p>
<p> (6) 观察用户如何工作。   </p>
<h5 id="确定目标系统的业务工作流"><a href="#确定目标系统的业务工作流" class="headerlink" title="确定目标系统的业务工作流"></a>确定目标系统的业务工作流</h5><p>  具体到当前待开发的应用系统，确定系统的业务工作流和主要的业务规则，采取需求调研的方法获取所需的信息.</p>
<h5 id="需求整理与总结"><a href="#需求整理与总结" class="headerlink" title="需求整理与总结"></a>需求整理与总结</h5><p>必须对上面步骤取得的需求资料进行整理和总结，确定对软件系统的综合要求，即软件的需求。</p>
<p>并提出这些需求实现条件，以及需求应达到的标准。</p>
<p>这些需求包括功能需求、性能需求、环境需求、可靠性需求、安全保密要求、用户界面需求、资源使用需求、软件成本消耗与开发进度需求等。</p>
<h4 id="3-软件需求分析阶段的任务"><a href="#3-软件需求分析阶段的任务" class="headerlink" title="3.软件需求分析阶段的任务"></a>3.软件需求分析阶段的任务</h4><img src="/2022/05/18/software/image-20220603112747635.png" class="" title="image-20220603112747635">

<p>可以把软件需求分析阶段的工作分为4个步骤，即获取需求、分析需求、定义需求和验证需求，如图所示。 </p>
<h5 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h5><p>  通过启发、引导从客户（或用户）那里得到的原始需求是他们的业务要求（needs），简称为N。</p>
<p>  这是分析之前获取的需求，其中可能存在一些实际问题，这些问题只有通过分析才能得到解决，直接把获取的需求作为软件设计阶段的依据将会导致严重的后果。 </p>
<h5 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h5><p>  认真研究获取的需求，必须考虑以下几方面：</p>
<p>  (1) 完整性：每项获取的需求都应给出清楚的描述，使得软件开发工作能够取得设计和实现该功能所需要的全部必要信息。</p>
<p>  (2) 正确性：获取的每项需求必须是准确无误的，并且需求描述无歧义性。</p>
<p>  (3) 合理性：各项需求之间、软件需求与系统需求之间应是协调一致的，不应存在矛盾和冲突。</p>
<p>  (4) 可行性：包括技术可行性 、经济可行性 、社会可行性 。</p>
<p>  (5) 充分性：获取的需求是否全面、周到。 </p>
<p>由于分析的过程会对获取的需求做部分调整，也即从获取的需求N中去掉了一些a，又补充了一些c，从而得到的是分析的需求R1（b+c）。</p>
<img src="/2022/05/18/software/image-20220603112918627.png" class="" title="image-20220603112918627">

<h5 id="需求定义"><a href="#需求定义" class="headerlink" title="需求定义"></a>需求定义</h5><p>  将已经过分析的需求清晰、全面、系统、准确地描述成为正式的文档，这一步定义需求的工作就是编写需求规格说明。 </p>
<h5 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h5><p>  为了确保已定义的需求（需求规格说明）准确无误，并能为客户（或用户）理解和接受，需要对其进行严格的评审。 </p>
<h3 id="3-2结构化分析方法"><a href="#3-2结构化分析方法" class="headerlink" title="3.2结构化分析方法"></a>3.2结构化分析方法</h3><p>•结构化分析模型</p>
<p>  结构化分析方法是一种建模技术，它建立的分析模型如图所示。</p>
<img src="/2022/05/18/software/image-20220603113107619.png" class="" title="image-20220603113107619">



<h4 id="1-功能建模（数据流图）"><a href="#1-功能建模（数据流图）" class="headerlink" title="1.功能建模（数据流图）"></a>1.功能建模（数据流图）</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>  功能建模的思想就是用抽象模型的概念，按照软件内部数据传递、变换的关系，自顶向下逐层分解，直到找到满足功能要求的所有可实现的软件为止。功能模型用数据流图来描述。</p>
<p>基本图形符号：（注意命名的词性）</p>
<img src="/2022/05/18/software/image-20220603113745154.png" class="" title="image-20220603113745154">

<p>数据源或数据汇点表示图中要处理数据的输入来源或处理结果要送往何处，数据源或数据汇点不是目标系统的一部分，只是目标系统的外围环境中的实体部分，因此称为外部实体。实际问题中可能是组织、部门、人、相关的软件系统或硬件设备。</p>
<p>数据流表示数据沿箭头方向的流动。数据流可表示在加工之间被传送的有名数据，也可表示未命名数据；这些数据虽然没有命名，但因其所连接的是有名加工和有名数据存储，所以含义也是清楚的。</p>
<p>加工是对数据对象的处理或变换，加工的名字是动词短语，以表明所完成的加工。一个加工可能需要多个数据流，也可能产生多个数据流。</p>
<p>数据存储在数据流图中起保存数据的作用，可以是数据库文件或任何形式的数据组织。从数据存储中引出的数据流可理解为从数据存储读取数据或得到查询结果，指向数据存储的数据流理解为向数据存储写入数据。</p>
<p>多个数据流之间关系：</p>
<img src="/2022/05/18/software/image-20220603113825262.png" class="" title="image-20220603113825262">

<h5 id="环境图"><a href="#环境图" class="headerlink" title="环境图"></a>环境图</h5><p>环境图（context diagram）也称为顶层数据流图（或0层数据流图），它仅包括一个数据处理过程，也就是要开发的目标系统。</p>
<p>环境图的作用是确定系统在其环境中的位置，通过确定系统的输入和输出与外部实体的关系确定其边界。</p>
<img src="/2022/05/18/software/image-20220603113853438.png" class="" title="image-20220603113853438">

<img src="/2022/05/18/software/image-20220603113906285.png" class="" title="image-20220603113906285">

<h5 id="数据流图的分层"><a href="#数据流图的分层" class="headerlink" title="数据流图的分层"></a>数据流图的分层</h5><p>对于稍微复杂一些的实际问题，在数据流图上常常出现十几个甚至几十个加工，这样的数据流图看起来不直观，不易理解，分层的数据流图能很好地解决这一问题。</p>
<p>按照系统的层次结构进行逐步分解，并以分层的数据流图反映这种结构关系，能清楚地表达和容易理解整个系统。 </p>
<img src="/2022/05/18/software/image-20220603113931039.png" class="" title="image-20220603113931039">

<p>招生系统的S0分解为S1-S4：</p>
<img src="/2022/05/18/software/image-20220603114022687.png" class="" title="image-20220603114022687">

<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>银行储蓄系统的业务流程：</p>
<p>储户填写的存款单或取款单由业务员键入系统；</p>
<p>如果是存款则系统记录存款人姓名、住址（或电话号码）、身份证号码、存款类型、存款日期、到期日期、利率、密码（可选）等信息，并印出存单给储户；</p>
<p>如果是取款而且开户时留有密码，则系统首先核对储户密码，若密码正确或存款时未留密码，则系统计算利息并印出利息清单给储户。</p>
<p>要求画出分层的数据流图，并细化到2层数据流图。</p>
<p>答案</p>
<p>(1) 识别外部实体及输入输出数据流。</p>
<p>外部实体：储户、业务员。</p>
<p>输入数据：如果需要储户输入密码，储户才直接与系统进行交互。储户填写的存款或取款信息通过业务员键入系统，可以将存款及取款信息抽象为事务。</p>
<p>输出数据：存款单，利息清单。 </p>
<p>(2) 画出环境图（顶层数据流图） </p>
<img src="/2022/05/18/software/image-20220603114710718.png" class="" title="image-20220603114710718">

<p>(3) 画出一层数据流图 </p>
<img src="/2022/05/18/software/image-20220603114722278.png" class="" title="image-20220603114722278">

<p>对环境图中的银行储蓄系统进行分解，从大的方面分解为接收事务、处理存款、处理取款3部分，得到1层数据流图。</p>
<p>接收事务的主要功能是判断一个事务（输入数据流）的类型，其结果或者是存款业务，或者是取款业务。</p>
<p>存款信息需要使用外部文件或数据库的方式来存储 。</p>
<p>(4) 画出二层数据流图</p>
<p>  对一层图中的“处理存款”及“处理取款”进行进一步分解，得到二层数据流图，即处理存款的数据流图和处理取款的数据流图。 </p>
<img src="/2022/05/18/software/image-20220603114819410.png" class="" title="image-20220603114819410">

<img src="/2022/05/18/software/image-20220603114824342.png" class="" title="image-20220603114824342">



<h4 id="2-数据建模（ER图）"><a href="#2-数据建模（ER图）" class="headerlink" title="2.数据建模（ER图）"></a>2.数据建模（ER图）</h4><p>在结构化分析方法中，使用实体—关系建模技术来建立数据模型。</p>
<p>这种技术是在较高的抽象层次（概念层）上对数据库结构进行建模的流行技术。</p>
<p>实体—关系模型表示为可视化的实体—关系图（entity-relationship diagram，ERD），也称为ER图。</p>
<p>ER图中仅包含3种相互关联的元素：数据对象（实体）、描述数据对象的属性及数据对象彼此间相互连接的关系。 </p>
<h5 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h5><p>数据对象是目标系统所需要的复合信息的表示，所谓复合信息是具有若干不同属性的信息。在ER图中用矩形表示数据对象。</p>
<p>在实际问题中，数据对象（实体）可以是外部实体、事物、角色、行为或事件、组织单位、地点或结构等。  </p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>属性定义数据对象的特征，如数据对象学生的学号、姓名、性别、专业等，课程的课程编号、课程名称、学分等。</p>
<p>在ER图中用椭圆或圆角矩形表示属性，并用无向边将属性与相关的数据对象连接在一起。</p>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><p>不同数据对象的实例之间是有关联关系的，在ER图上用无向边表示。在无向边的两端应标识出关联实例的数量，也称为关联的重数。从关联重数的角度可以将关联分为３种。</p>
<p>(1) 一对一（1:1）关联</p>
<p>(2) 一对多（1:m）关联</p>
<p>(3) 多对多（m:n）关联</p>
<p>实例关联还有“必须”和“可选”之分。 </p>
<p>关联数量的表示</p>
<p>在ER图中用圆圈表示所关联的实例是可选的，隐含表示“0”，没有出现圆圈就意味着是必须的。出现在连线上的短竖线可以看成是“1”。 </p>
<img src="/2022/05/18/software/image-20220603115019362.png" class="" title="image-20220603115019362">

<img src="/2022/05/18/software/image-20220603115023829.png" class="" title="image-20220603115023829">

<h5 id="关系的属性"><a href="#关系的属性" class="headerlink" title="关系的属性"></a>关系的属性</h5><p>关系本身也可能有属性，这在多对多的关系中尤其常见，如学生和课程之间的关系可起名为“选课”，其属性应该有学期、成绩等。</p>
<p>关系属性的表示：在表示关系的无向边上再加一个菱形框，并在菱形框中标明关系的名字，关系的属性同样用椭圆形或圆角矩形表示，并用无向边将关系与其属性连接起来。  </p>
<img src="/2022/05/18/software/image-20220603115042845.png" class="" title="image-20220603115042845">

<p>银行储蓄系统ER图：</p>
<img src="/2022/05/18/software/image-20220603115055590.png" class="" title="image-20220603115055590">

<h4 id="3-行为建模（状态图）"><a href="#3-行为建模（状态图）" class="headerlink" title="3.行为建模（状态图）"></a>3.行为建模（状态图）</h4><p>没大看懂？什么事件？什么守卫表达式？</p>
<p>状态转换图（简称状态图）通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。状态图中使用的主要符号如图所示。</p>
<img src="/2022/05/18/software/image-20220603115121625.png" class="" title="image-20220603115121625">

<h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p>状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式，状态规定了系统对事件的响应方式。</p>
<p>状态可能有：初态（初始状态）、终态（最终状态）和中间态。</p>
<p>在一张状态图中只能有一个初态，而终态则可以有多个，也可以没有。 </p>
<h5 id="状态的表示"><a href="#状态的表示" class="headerlink" title="状态的表示"></a>状态的表示</h5><p>初态用实心圆表示，终态用牛眼图形表示，中间态用圆角矩形表示。</p>
<img src="/2022/05/18/software/image-20220603115158805.png" class="" title="image-20220603115158805">

<h5 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h5><p>状态图中两个状态之间带箭头的连线称为状态转换。</p>
<p>状态的变迁通常是由事件触发的，在这种情况下应在表示状态转换的箭头线上标出触发转换的事件表达式。</p>
<p>如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换。</p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>事件是在某个特定时刻发生的事情，它是对引起系统做动作或从一个状态转换到另一个状态的外部事件的抽象。事件表达式的语法如下：</p>
<p>​    <strong>事件说明（守卫条件）/动作表达式</strong></p>
<p>(1) 事件说明的语法如下：</p>
<p>​    事件名（参数表）</p>
<p>(2) 守卫条件是一个布尔表达式。如果同时使用守卫条件和事件说明，则当且仅当事件发生且布尔表达式成立时，状态转换才发生。如果只有守卫条件没有事件说明，则只要守卫条件为真，状态转换就发生。</p>
<p>(3) 动作表达式是一个过程表达式，当状态转换开始时执行该表达式。</p>
<p>存款过程的状态图：</p>
<img src="/2022/05/18/software/image-20220603115739467.png" class="" title="image-20220603115739467">

<p>取款过程的状态图：</p>
<img src="/2022/05/18/software/image-20220603120002763.png" class="" title="image-20220603120002763">

<h4 id="4-数据字典"><a href="#4-数据字典" class="headerlink" title="4.数据字典"></a>4.数据字典</h4><p>数据字典以词条方式定义在数据模型、功能模型和行为模型中出现的数据对象及控制信息的特性，给出它们的准确定义，包括数据流、加工、数据文件、数据元素，以及数据源点、数据汇点等。 </p>
<p>数据字典成为把3种分析模型黏合在一起的“黏合剂”，是分析模型的“核心”。</p>
<h5 id="词条描述"><a href="#词条描述" class="headerlink" title="词条描述"></a>词条描述</h5><p>对于在数据流图中每一个被命名的图形元素均加以定义；</p>
<p>其内容包括图形元素的名字，图形元素的别名或编号，图形元素类别（如加工、数据流、数据文件、数据元素、数据源点或数据汇点等）、描述、定义、位置等。 </p>
<h6 id="数据流词条"><a href="#数据流词条" class="headerlink" title="数据流词条"></a>数据流词条</h6><p>数据流是数据结构在系统内传播的路径，数据流词条应包括以下几项内容。</p>
<p>①数据流名：要求与数据流图中该图形元素的名字一致。</p>
<p>②简述：简要介绍它产生的原因和结果。</p>
<p>③组成：数据流的数据结构。</p>
<p>④来源：数据流来自哪个加工或作为哪个数据源的外部实体。</p>
<p>⑤去向：数据流流向哪个加工或作为哪个数据汇点的外部实体。</p>
<p>⑥流通量：单位时间数据的流通量。</p>
<p>⑦峰值：流通量的极限值。</p>
<h6 id="数据元素词条"><a href="#数据元素词条" class="headerlink" title="数据元素词条"></a>数据元素词条</h6><p>数据流图中的每个数据结构都是由数据元素构成的，数据元素是数据处理中最小的、不可再分的单位，它直接反映事物的某一特征。</p>
<p>① 类型：数据元素分为数字型与文字型。数字型又分为离散值和连续值，文字的类型用编码类型和长度区分。</p>
<p>② 取值范围：离散值的取值或是枚举的（如3，17，21），或是介于上下界的一组数（如2..100）；连续值一般是有取值范围的实数集（如0.0..100.0）。对于文字型，文字的取值需加以定义。</p>
<p>③ 相关的数据元素及数据结构。 </p>
<h6 id="数据存储文件词条"><a href="#数据存储文件词条" class="headerlink" title="数据存储文件词条"></a>数据存储文件词条</h6><p>数据存储文件是数据保存的地方。一个数据存储文件词条应有以下几项内容。</p>
<p>① 文件名：要求与数据流图中该图形元素的名字一致。</p>
<p>② 简述：简要介绍存放的是什么数据。</p>
<p>③ 组成：文件的数据结构。</p>
<p>④ 输入：从哪些加工获取数据。</p>
<p>⑤ 输出：由哪些加工使用数据。</p>
<p>⑥ 存取方式：分为顺序、直接、关键码等不同存取方式。</p>
<p>⑦ 存取频率：单位时间的存取次数。</p>
<h6 id="加工词条"><a href="#加工词条" class="headerlink" title="加工词条"></a>加工词条</h6><p>加工可以使用诸如判定表、判定树、结构化语言等形式表达，主要描述如下。</p>
<p>① 加工名：要求与数据流图中该图形元素的名字一致。</p>
<p>② 编号：用以反映该加工的层次和父子关系。</p>
<p>③ 简述：加工逻辑及功能简述。</p>
<p>④ 输入：加工的输入数据流。</p>
<p>⑤ 输出：加工的输出数据流。</p>
<p>⑥ 加工逻辑：简述加工程序和加工顺序。</p>
<h6 id="数据源点及数据汇点词条"><a href="#数据源点及数据汇点词条" class="headerlink" title="数据源点及数据汇点词条"></a>数据源点及数据汇点词条</h6><p>对于一个数据处理系统来说，数据源点和数据汇点应比较少。 </p>
<p>① 名称：要求与数据流图中该外部实体的名字一致。</p>
<p>② 简述：简要描述是什么外部实体。</p>
<p>③ 有关数据流：该实体与系统交互时涉及哪些数据流。</p>
<p>④ 数目：该实体与系统交互的次数。</p>
<h5 id="数据结构描述"><a href="#数据结构描述" class="headerlink" title="数据结构描述"></a>数据结构描述</h5><p>在数据字典的编制中，分析员最常用的描述数据结构的方式有定义式、Warnier图等。</p>
<p>定义式。在数据流图中，数据流和数据文件都具有一定的数据结构，因此，必须以一种清晰、准确、无二义性的方式来描述数据结构。</p>
<p>Warnier图。Warnier图是表示数据结构的另一种图形工具，它用树形结构来描绘数据结构。</p>
<img src="/2022/05/18/software/image-20220603151231384.png" class="" title="image-20220603151231384">

<p>存折的定义格式</p>
<p>存折＝户名＋所号＋账号＋开户日＋性质＋（印密）＋  1{存取行}50</p>
<p>所号＝“001”..“999”</p>
<p>户名＝2{字母}24</p>
<p>账号＝“00000000001”..“99999999999”</p>
<p>开户日＝年＋月＋日</p>
<p>性质＝“1”..“6”          </p>
<p>印密＝（“0”|“000001”..“999999”）  </p>
<p>存取行＝日期＋（摘要）＋支出＋存入＋余额＋操作＋复核</p>
<p>日期＝年＋月＋日</p>
<p>年＝“0001”..“9999”</p>
<p>月＝“01”..“12”</p>
<p>日＝“01”..“31”</p>
<p>Warnier图</p>
<img src="/2022/05/18/software/image-20220603151317289.png" class="" title="image-20220603151317289">

<h4 id="5-加工规格说明"><a href="#5-加工规格说明" class="headerlink" title="5.加工规格说明"></a>5.加工规格说明</h4><p>在对数据流图的分解中，位于层次树最低层的加工也称为基本加工或原子加工，对于每一个基本加工都需要进一步说明，这称为加工规格说明。</p>
<p>在编写基本加工的规格说明时，主要目的是要表达“做什么”，而不是“怎样做”。</p>
<p>加工规格说明应满足如下的要求：</p>
<p>(1) 对数据流图的每一个基本加工，必须有一个加工规格说明。</p>
<p>(2) 加工规格说明必须描述基本加工如何把输入数据流变换为输出数据流的加工规则。</p>
<p>(3) 加工规格说明必须描述实现加工的策略而不是实现加工的细节。</p>
<p>(4) 加工规格说明中包含的信息应是充足的，完备的，有用的，没有重复的多余信息。</p>
<h5 id="决策表"><a href="#决策表" class="headerlink" title="决策表"></a>决策表</h5><p>决策表由4个部分组成：</p>
<p>左上部分是条件茬，在此区域列出了各种可能的单个条件；</p>
<p>左下部分是动作茬，在此区域列出了可能采取的单个动作；</p>
<p>右上部分是条件项，在此区域列出了针对各种条件的每一组条件取值的组合；</p>
<p>右下部分是动作项，这些动作项与条件项紧密相关，它指出了在条件项的各组取值的组合情况下应采取的动作。</p>
<p>建立决策表的步骤</p>
<p>(1) 列出与一个具体过程（或模块）有关的所有处理。</p>
<p>(2) 列出过程执行期间的所有条件（或所有判断）。</p>
<p>(3) 将特定条件取值组合与特定的处理相匹配，消去不可能发生的条件取值组合。</p>
<p>(4) 将右部每一纵列规定为一个处理规则，即对于某一条件取值组合将有什么动作。</p>
<img src="/2022/05/18/software/image-20220603151450854.png" class="" title="image-20220603151450854">

<p>决策表的改进：如果表中有两条或更多的处理规则具有相同的动作，并且其条件项之间存在着某种关系，就可设法将它们合并。 </p>
<img src="/2022/05/18/software/image-20220603151514659.png" class="" title="image-20220603151514659">

<h5 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h5><p>决策树（decision tree）也是用来表达加工逻辑的一种工具，有时侯它比决策表更直观。</p>
<p>检查订货单的决策树 </p>
<img src="/2022/05/18/software/image-20220603151600923.png" class="" title="image-20220603151600923">



<h3 id="3-3系统需求规格说明"><a href="#3-3系统需求规格说明" class="headerlink" title="3.3系统需求规格说明"></a>3.3系统需求规格说明</h3><p>这三节看课本</p>
<h3 id="3-4需求评审"><a href="#3-4需求评审" class="headerlink" title="3.4需求评审"></a>3.4需求评审</h3><h3 id="3-5需求管理"><a href="#3-5需求管理" class="headerlink" title="3.5需求管理"></a>3.5需求管理</h3><h2 id="4-结构化设计方法"><a href="#4-结构化设计方法" class="headerlink" title="4.结构化设计方法"></a>4.结构化设计方法</h2><h3 id="4-1软件设计的概念及原则"><a href="#4-1软件设计的概念及原则" class="headerlink" title="4.1软件设计的概念及原则"></a>4.1软件设计的概念及原则</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>设计是一项核心的工程活动。</p>
<p>“什么是设计？设计是你站在两个世界——技术世界和人类的目标世界——而你尝试将这两个世界结合在一起……”。</p>
<p>“设计良好的建筑应该展示出坚固、适用和令人赏心悦目”。</p>
<h4 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h4><h5 id="1-分而治之"><a href="#1-分而治之" class="headerlink" title="(1) 分而治之"></a>(1) 分而治之</h5><p>分而治之是人们解决大型复杂问题时通常采用的策略。将大型复杂的问题分解为许多容易解决的小问题，原来的问题也就容易解决了。</p>
<p>软件的体系结构设计、模块化设计都是分而治之策略的具体表现。</p>
<p>模块是构成软件的基本构件。模块化是将整体软件划分成独立命名且可以独立访问的模块，不同的模块通常具有不同的功能或指责，每个模块可独立地开发吗、测试，最后组装成完整的软件。</p>
<p>尽管模块分解可以简化要解决的问题，但模块分解并不是越小越好。</p>
<p>当模块数目增加时，每个模块的规模将减小，开发单个模块的成本确实减少了；但是，随着模块数目增加，模块之间关系的复杂程度也会增加，设计模块间接口所需要的工作量也将增加，如图所示。</p>
<img src="/2022/05/18/software/image-20220603155004206.png" class="" title="image-20220603155004206">

<h5 id="2-模块独立性"><a href="#2-模块独立性" class="headerlink" title="(2) 模块独立性"></a>(2) 模块独立性</h5><p>定义: 是指软件系统中每个模块只涉及软件要求的具体的子功能, 而和软件系统中其它模块的接口是简单的。</p>
<p>有效的模块化使软件便于分工协作开发。</p>
<p>独立的模块比较容易测试和维护。</p>
<p>模块独立性的度量准则</p>
<p>内聚:是模块功能强度(一个模块内部各个元素彼此结合的紧密程度)的度量。</p>
<p>耦合:是模块之间的互相连接的紧密程度的度量。</p>
<p>模块独立性比较强的模块应是<strong>高内聚低耦合</strong>的模块。</p>
<h6 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h6><img src="/2022/05/18/software/image-20220603155242879.png" class="" title="image-20220603155242879">

<h6 id="非直接耦合-Nondirect-Coupling"><a href="#非直接耦合-Nondirect-Coupling" class="headerlink" title="非直接耦合(Nondirect Coupling)"></a>非直接耦合(Nondirect Coupling)</h6><p>两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</p>
<p>非直接耦合的模块独立性最强。</p>
<img src="/2022/05/18/software/image-20220603155419800.png" class="" title="image-20220603155419800">

<h6 id="数据耦合-Data-Coupling"><a href="#数据耦合-Data-Coupling" class="headerlink" title="数据耦合 (Data Coupling)"></a>数据耦合 (Data Coupling)</h6><p>一个模块访问另一个模块时，彼此之间是通过简单数据参数 (不是控制参数、公共数据结构或外部变量) 来交换输入、输出信息的。也是较理想的耦合。</p>
<img src="/2022/05/18/software/image-20220603155527500.png" class="" title="image-20220603155527500">

<h6 id="特征耦合-Stamp-Coupling"><a href="#特征耦合-Stamp-Coupling" class="headerlink" title="特征耦合 (Stamp Coupling)"></a>特征耦合 (Stamp Coupling)</h6><p>一组模块通过<strong>参数表</strong>传递记录信息，就是特征耦合。这个记录是某一数据结构的子结构，而不是简单变量。</p>
<h6 id="控制耦合-Control-Coupling"><a href="#控制耦合-Control-Coupling" class="headerlink" title="控制耦合 (Control Coupling)"></a>控制耦合 (Control Coupling)</h6><p>如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。</p>
<img src="/2022/05/18/software/image-20220603155642366.png" class="" title="image-20220603155642366">

<h6 id="公共耦合（Common-Coupling）"><a href="#公共耦合（Common-Coupling）" class="headerlink" title="公共耦合（Common Coupling）"></a>公共耦合（Common Coupling）</h6><p>若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。</p>
<p>公共数据区为全局变量/数组等</p>
<img src="/2022/05/18/software/image-20220603155707112.png" class="" title="image-20220603155707112">

<h6 id="内容耦合-Content-Coupling"><a href="#内容耦合-Content-Coupling" class="headerlink" title="内容耦合 (Content Coupling)"></a>内容耦合 (Content Coupling)</h6><p>一个模块直接访问另一个模块的内部数据。</p>
<p>一个模块不通过正常入口转到另一模块内部。</p>
<p>两个模块有一部分程序代码重迭。(只可能出现在汇编语言中)。</p>
<p>一个模块有多个入口。</p>
<img src="/2022/05/18/software/image-20220603155804255.png" class="" title="image-20220603155804255">

<p>设计原则</p>
<ul>
<li>尽量使用数据耦合</li>
<li>少用控制耦合</li>
<li>限制使用公共耦合（除非传递大量数据）</li>
<li>完全不用内容耦合</li>
</ul>
<p>实际上，两个模块之间的耦合不只是一种类型，而是多种类型的混合。这就要求设计人员进行分析、比较，逐步加以改进，以提高模块的独立性。</p>
<h6 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h6><img src="/2022/05/18/software/image-20220603155955925.png" class="" title="image-20220603155955925">

<h6 id="偶然内聚（Coincidental-Cohesion）"><a href="#偶然内聚（Coincidental-Cohesion）" class="headerlink" title="偶然内聚（Coincidental Cohesion）"></a>偶然内聚（Coincidental Cohesion）</h6><p>当模块内各部分之间没有联系，或者即使有联系，这种联系也很松散，则称这种模块为偶然内聚模块，内聚程度最低。</p>
<p>缺点：</p>
<p> 1）内容不易理解，很难描述其功能。</p>
<p> 2）把完整的程序分割到多个模块中，在程序运行时会频繁地互相调用。</p>
<img src="/2022/05/18/software/image-20220603160108583.png" class="" title="image-20220603160108583">

<h6 id="逻辑内聚（Logical-Cohesion）"><a href="#逻辑内聚（Logical-Cohesion）" class="headerlink" title="逻辑内聚（Logical Cohesion）"></a>逻辑内聚（Logical Cohesion）</h6><p>把几种相关的功能组合在一起，每次被调用时，由传送给模块的判定参数来确定该模块应执行哪个功能。</p>
<p>缺点</p>
<p> 1）不易修改，因包含多个功能</p>
<p> 2）需传递控制参数——控制耦合</p>
<p> 3）未用部分调入内存，影响效率</p>
<p>但是如果程序只是由一堆if或case和调用其他子程序的语句组成，这种逻辑内聚也是很好的。例如：事件处理器。</p>
<img src="/2022/05/18/software/image-20220603160127680.png" class="" title="image-20220603160127680">

<h6 id="时间内聚（Classical-Cohesion）"><a href="#时间内聚（Classical-Cohesion）" class="headerlink" title="时间内聚（Classical Cohesion）"></a>时间内聚（Classical Cohesion）</h6><p>时间内聚模块大多为多功能模块，但模块的各个功能的执行与时间有关，通常要求所有功能必须在同一时间段内执行。</p>
<p>例如：</p>
<p>1.初始化模块和终止模块。</p>
<p>2.紧急故障处理模块：关闭文件、报警、保留现场必须无中断地同时处理</p>
<p>时间内聚模块比逻辑内聚模块的内聚程度又稍高一些。在一般情形下，各部分可以以任意的顺序执行，所以它的内部逻辑更简单。</p>
<h6 id="过程内聚（Procedural-Cohesion）"><a href="#过程内聚（Procedural-Cohesion）" class="headerlink" title="过程内聚（Procedural Cohesion）"></a>过程内聚（Procedural Cohesion）</h6><p>如果一个模块内的处理是相关的，而且必须以特定次序执行，则是过程内聚。</p>
<p>使用流程图做为工具设计程序时，把流程图中的某一部分划出组成模块，就得到过程内聚模块。<br> 例如，把流程图中的循环部分、判定部分、计算部分分成三个模块，这三个模块都是过程内聚模块。</p>
<p> 过程内聚仅包含完整功能的一部分。</p>
<h6 id="通信内聚（Communicational-Cohesion-亦称数据内聚"><a href="#通信内聚（Communicational-Cohesion-亦称数据内聚" class="headerlink" title="通信内聚（Communicational Cohesion) 亦称数据内聚"></a>通信内聚（Communicational Cohesion) 亦称数据内聚</h6><p>一个模块中所有处理元素都使用同一个输入数据和产生同一个输出数据。</p>
<p>例如：模块A:从文件file读取数据</p>
<p>​      由数据产生报表A</p>
<p>​      由数据产生报表B</p>
<h6 id="顺序内聚"><a href="#顺序内聚" class="headerlink" title="顺序内聚"></a>顺序内聚</h6><p>一个模块中的处理元素和同一功能密切相关，而且这些处理必须顺序执行，则称为顺序内聚。</p>
<p>根据数据流图划分模块时，通常得到顺序内聚的模块。</p>
<img src="/2022/05/18/software/image-20220603160607276.png" class="" title="image-20220603160607276">

<h6 id="功能内聚-Functional-Cohesion"><a href="#功能内聚-Functional-Cohesion" class="headerlink" title="功能内聚 (Functional Cohesion)"></a>功能内聚 (Functional Cohesion)</h6><p>一个模块中各个部分都是完成某一具体功能必不可少的组成部分，或者说该模块中所有部分都是为了完成一项具体功能而协同工作，紧密联系，不可分割的。则称该模块为功能内聚模块。</p>
<p>优点：容易修改和维护</p>
<h5 id="3-提高抽象层次"><a href="#3-提高抽象层次" class="headerlink" title="(3) 提高抽象层次"></a>(3) 提高抽象层次</h5><p>抽象是指忽视一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。</p>
<p>当我们进行软件设计时，设计开始时应尽量提高软件的抽象层次，按抽象级别从高到低进行软件设计。</p>
<h5 id="4-复用性设计"><a href="#4-复用性设计" class="headerlink" title="(4) 复用性设计"></a>(4) 复用性设计</h5><p>复用是指同一事物不做修改或稍加修改就可以多次重复使用。将复用的思想用于软件开发，称为软件复用。</p>
<p>我们将软件的重用部分称为软构件。</p>
<p>也就是说，在构造新的软件系统时不必从零做起，可以直接使用已有的软构件即可组装（或加以合理修改）成新的系统。</p>
<h5 id="5-灵活性设计"><a href="#5-灵活性设计" class="headerlink" title="(5) 灵活性设计"></a>(5) 灵活性设计</h5><p>保证软件灵活性设计的关键是抽象。</p>
<p>面向对象系统中的类结构类似一座金字塔，越接近金字塔的顶端，抽象程度就越高。</p>
<p>“抽象”的反义词是“具体”。理想情况下，一个系统的任何代码、逻缉、概念在这个系统中都应该是唯一的，也就是说不存在重复的代码。</p>
<p>在设计中引入灵活性的方法有：</p>
<ol>
<li>降低耦合并提高内聚（易于提高替换能力）； </li>
<li>建立抽象（创建有多态操作的接口和父类）；</li>
<li>不要将代码写死（消除代码中的常数）； </li>
<li>抛出异常（由操作的调用者处理异常）；</li>
<li>使用并创建可复用的代码。</li>
</ol>
<h3 id="4-2结构化设计"><a href="#4-2结构化设计" class="headerlink" title="4.2结构化设计"></a>4.2结构化设计</h3><h4 id="结构化软件设计的任务"><a href="#结构化软件设计的任务" class="headerlink" title="结构化软件设计的任务"></a>结构化软件设计的任务</h4><p>从工程管理的角度，可以将软件设计分为概要设计阶段和详细设计阶段。</p>
<p>从技术的角度，传统的结构化方法将软件设计划分为<strong>体系结构设计、数据设计、接口设计和过程设计</strong>4部分；</p>
<p>面向对象方法则将软件设计划分为体系结构设计、类设计/数据设计、接口设计和构件级设计4部分。</p>
<img src="/2022/05/18/software/image-20220603161041687.png" class="" title="image-20220603161041687">

<p>体系结构设计：体系结构设计定义软件的主要结构元素及其之间的关系。通常称为模块设计。</p>
<p>接口设计（内部、外部接口）：接口设计描述用户界面，软件和其他硬件设备、其他软件系统及使用人员的外部接口，以及各种构件之间的内部接口。</p>
<p>数据设计：传统方法主要根据需求阶段所建立的实体—关系图（ER图）来确定软件涉及的文件系统的结构及数据库的表结构。 </p>
<p>过程设计：过程设计的主要工作是确定软件各个组成部分内的算法及内部数据结构，并选定某种过程的表达形式来描述各种算法。</p>
<h4 id="结构化设计与结构化分析的关系"><a href="#结构化设计与结构化分析的关系" class="headerlink" title="结构化设计与结构化分析的关系"></a>结构化设计与结构化分析的关系</h4><img src="/2022/05/18/software/image-20220603161117041.png" class="" title="image-20220603161117041">

<p>结构化设计方法的实施要点</p>
<p>(1) 研究、分析和审查数据流图。</p>
<p>(2) 根据数据流图决定问题的类型：变换型和事务型。针对两种不同的类型分别进行分析处理。</p>
<p>(3) 由数据流图推导出系统的初始结构图。</p>
<p>(4) 利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止。</p>
<p>(5) 根据分析模型中的实体关系图和数据字典进行数据设计，包括数据库设计或数据文件的设计。</p>
<p>(6) 在上面设计的基础上，并依据分析模型中的加工规格说明、状态转换图进行过程设计。</p>
<p>(7) 制定测试计划。</p>
<h4 id="模块结构及表示"><a href="#模块结构及表示" class="headerlink" title="模块结构及表示"></a>模块结构及表示</h4><p>一般通过功能划分过程来完成软件结构设计。功能划分过程从需求分析确立的目标系统的模型出发，对整个问题进行分割，使其每一部分用一个或几个软件模块加以解决，整个问题就解决了。</p>
<img src="/2022/05/18/software/image-20220603161953508.png" class="" title="image-20220603161953508">

<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>一个软件系统通常由很多模块组成，结构化程序设计中的函数和子程序都可称为模块，它是程序语句按逻辑关系建立起来的组合体。</p>
<p>模块用矩形框表示，并用模块的名字标记它。</p>
<img src="/2022/05/18/software/image-20220603162026214.png" class="" title="image-20220603162026214">

<p>大模块还可以分解，不能分解的最小模块称为原子模块。如果一个软件系统的全部数据计算或处理都由原子模块完成，其他非原子模块仅执行控制或协调功能，这样的系统就是完全因子分解的系统。完全因子分解的系统被认为是最好的系统。但实际上大多数做不到。</p>
<h5 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h5><img src="/2022/05/18/software/image-20220603162404141.png" class="" title="image-20220603162404141">

<h5 id="模块的结构"><a href="#模块的结构" class="headerlink" title="模块的结构"></a>模块的结构</h5><p>模块结构最普通的形式就是树状结构和网状结构，如图所示。</p>
<img src="/2022/05/18/software/image-20220603163158886.png" class="" title="image-20220603163158886">

<h5 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h5><p>结构图（structure chart，SC）是精确表达模块结构的图形表示工具。</p>
<p>(1) 模块的调用关系和接口：在结构图中，两个模块之间用单向箭头连接。</p>
<p>(2) 模块间的信息传递：当一个模块调用另一个模块时，调用模块把数据或控制信息传送给被调用模块，以使被调用模块能够运行。 </p>
<p>模块间的调用关系和接口表示 </p>
<img src="/2022/05/18/software/image-20220603163259211.png" class="" title="image-20220603163259211">

<p>(3) 条件调用和循环调用 ：<strong>当模块A有条件地调用另一个模块B时，在模块A的箭头尾部标以一个菱形符号</strong>；当一个模块<strong>A反复地调用</strong>模块C和模块D时，在调用箭头尾部则标以一个弧形符号。</p>
<img src="/2022/05/18/software/image-20220603163334550.png" class="" title="image-20220603163334550">

<p>(4) 结构图的形态特征。在图中，上级模块调用下级模块，它们之间存在主从关系。相关概念：宽度、深度、扇入、扇出。</p>
<img src="/2022/05/18/software/image-20220603163405446.png" class="" title="image-20220603163405446">

<p>深度: 表示软件结构中从顶层模块到最底层模块的层数</p>
<p>宽度: 是软件结构在同一层次上的模块总数的最大值.一般来说,宽度越大系统就越复杂.</p>
<p>扇出: 指一个模块直接控制的下属模块个数,经验表明,一个设计的好的典型系统的平均扇出通常是3或4个,太多或太少都不好.</p>
<p>扇入: 指一个模块的直接上属模块个数</p>
<h4 id="数据结构及表示"><a href="#数据结构及表示" class="headerlink" title="数据结构及表示"></a>数据结构及表示</h4><p>数据结构是数据的各个元素之间逻辑关系的一种表示。</p>
<p>数据结构设计应确定数据的组织、存取方式、相关程度，以及信息的不同处理方法。</p>
<p>数据结构的组织方法和复杂程度可以灵活多样，但典型的数据结构种类是有限的，它们是构成一些更复杂结构的基本构件块。</p>
<img src="/2022/05/18/software/image-20220603163518942.png" class="" title="image-20220603163518942">

<h3 id="4-3体系结构设计"><a href="#4-3体系结构设计" class="headerlink" title="4.3体系结构设计"></a>4.3体系结构设计</h3><h4 id="基于数据流方法的设计过程"><a href="#基于数据流方法的设计过程" class="headerlink" title="基于数据流方法的设计过程"></a>基于数据流方法的设计过程</h4><p>基于数据流的设计方法也称为过程驱动的设计方法；</p>
<p>这种方法与软件需求分析阶段的结构化分析方法相衔接，可以很方便地将用数据流图表示的信息转换成程序结构的设计描述；</p>
<p>这种方法还能和编码阶段的“结构化程序设计方法”相适应，成为常用的结构化设计方法。</p>
<img src="/2022/05/18/software/image-20220603163639268.png" class="" title="image-20220603163639268">

<h4 id="典型的数据流类型和系统结构"><a href="#典型的数据流类型和系统结构" class="headerlink" title="典型的数据流类型和系统结构"></a>典型的数据流类型和系统结构</h4><p>典型的数据流类型有变换型数据流和事务型数据流，数据流的类型不同，得到的系统结构也不同。</p>
<p>通常，一个系统中的所有数据流都可以认为是变换流，但是，当遇到有明显事务特性的数据流时，建议采用事务型映射方法进行设计。</p>
<h5 id="变换型数据流和变换型系统结构图"><a href="#变换型数据流和变换型系统结构图" class="headerlink" title="变换型数据流和变换型系统结构图"></a>变换型数据流和变换型系统结构图</h5><p>变换型数据处理问题的工作过程大致分为3步，即取得数据、变换数据和给出数据，如图所示。</p>
<img src="/2022/05/18/software/image-20220603163711094.png" class="" title="image-20220603163711094">

<p>变换型系统的结构图由输入、中心变换和输出3部分组成。</p>
<img src="/2022/05/18/software/image-20220603163812405.png" class="" title="image-20220603163812405">

<h5 id="事务型数据流和事务型系统结构图"><a href="#事务型数据流和事务型系统结构图" class="headerlink" title="事务型数据流和事务型系统结构图"></a>事务型数据流和事务型系统结构图</h5><p>通常接受一项事务，根据事务处理的特点和性质，选择分派一个适当的处理单元，然后给出结果。</p>
<p>完成选择分派任务的部分称为事务处理中心，或分派部件。</p>
<img src="/2022/05/18/software/image-20220603163959630.png" class="" title="image-20220603163959630">

<p>结构图</p>
<img src="/2022/05/18/software/image-20220603164006927.png" class="" title="image-20220603164006927">

<p>简化的事务型系统结构图</p>
<p>事务型系统的结构图可以有多种不同的形式，如有多层操作层或没有操作层。</p>
<p>如果调度模块并不复杂，可将其归入事务中心模块。</p>
<img src="/2022/05/18/software/image-20220603164021844.png" class="" title="image-20220603164021844">

<h4 id="变换型映射方法"><a href="#变换型映射方法" class="headerlink" title="变换型映射方法"></a>变换型映射方法</h4><p>系统数据处理问题的处理流程总能表示为变换型数据流图，进一步可采用变换型映射方法建立系统的结构图。</p>
<p>也可能遇到明显的事务数据处理问题，这时可采用事务型映射方法。</p>
<p>变换分析方法的步骤</p>
<p>(1) 重画数据流图。在需求分析阶段得到的数据流图侧重于描述系统如何加工数据，而重画数据流图的出发点是描述系统中的数据是如何流动的。</p>
<p>(2)在数据流图上区分系统的逻辑输入、逻辑输出和中心变换部分。</p>
<img src="/2022/05/18/software/image-20220603164215622.png" class="" title="image-20220603164215622">

<p>(3) 进行一级分解，设计系统模块结构的顶层和第一层。自顶向下设计的关键是找出系统树形结构图的根或顶层模块。</p>
<p>首先设计一个主模块，并用程序的名字为它命名，然后将它画在与中心变换相对应的位置上。</p>
<p>第1层设计：为每个逻辑输入设计一个输入模块，它的功能是为主模块提供数据；为每个逻辑输出设计一个输出模块，它的功能是将主模块提供的数据输出；为中心变换设计一个变换模块，它的功能是将逻辑输入转换成逻辑输出。 第一层模块与主模块之间传送的数据应与数据流图相对应，如图所示。</p>
<img src="/2022/05/18/software/image-20220603164338830.png" class="" title="image-20220603164338830">

<p>(4) 进行二级分解，设计中、下层模块。</p>
<p>这一步工作是自顶向下，逐层细化，为每一个输入模块、输出模块、变换模块设计它们的从属模块。</p>
<p>设计下层模块的顺序是任意的。但一般是先设计输入模块的下层模块。</p>
<h4 id="事务型映射方法"><a href="#事务型映射方法" class="headerlink" title="事务型映射方法"></a>事务型映射方法</h4><p>事务分析也是从分析数据流图开始，自顶向下，逐步分解，建立系统的结构图。</p>
<img src="/2022/05/18/software/image-20220603164404468.png" class="" title="image-20220603164404468">

<p>事务分析方法的步骤</p>
<p>(1) 识别事务源。利用数据流图和数据词典，从问题定义和需求分析的结果中，找出各种需要处理的事务。</p>
<p>(2) 规定适当的事务型结构。在确定了该数据流图具有事务型特征之后，根据模块划分理论，建立适当的事务型结构。</p>
<p>(3) 识别各种事务和它们定义的操作。</p>
<p>(4) 注意利用公用模块。</p>
<p>(5) 建立事务处理模块。对每一事务，或对联系密切的一组事务，建立一个事务处理模块。</p>
<p>(6) 对事务处理模块规定它们全部的下层操作模块。</p>
<p>(7) 对操作模块规定它们的全部细节模块。</p>
<p>大型的软件系统通常是变换型结构和事务型结构的混合结构，所以，我们通常利用以变换分析为主，事务分析为辅的方式进行软件结构设计。</p>
<p>混合结构的例子</p>
<img src="/2022/05/18/software/image-20220603164444157.png" class="" title="image-20220603164444157">

<h4 id="软件模块结构的改进方法"><a href="#软件模块结构的改进方法" class="headerlink" title="软件模块结构的改进方法"></a>软件模块结构的改进方法</h4><h5 id="1-模块功能的完善化。"><a href="#1-模块功能的完善化。" class="headerlink" title="(1)模块功能的完善化。"></a>(1)模块功能的完善化。</h5><p>一个完整的功能模块，不仅能够完成指定的功能，而且还应当能够告诉使用者完成任务的状态，以及不能完成的原因。也就是说，一个完整的模块应当有以下几部分。</p>
<p>① 执行规定的功能的部分。</p>
<p>② 出错处理的部分。 当模块不能完成规定的功能时，必须回送出错标志，向它的调用者报告出现这种例外情况的原因。</p>
<p>③ 如果需要返回一系列数据给它的调用者，在完成数据加工或结束时，应当给它的调用者返回一个“结束标志”。</p>
<h5 id="2-消除重复功能，改善软件结构。"><a href="#2-消除重复功能，改善软件结构。" class="headerlink" title="(2) 消除重复功能，改善软件结构。"></a>(2) 消除重复功能，改善软件结构。</h5><p>① 完全相似。在结构上完全相似，可能只是在数据类型上不一致。此时可以采取完全合并的方法。图a</p>
<p>② 局部相似：此时，不可以把两者合并为一，如图(b)所示，因为这样在合并后的模块内部必须设置许多查询开关，如图(f)所示。 </p>
<img src="/2022/05/18/software/image-20220603164558998.png" class="" title="image-20220603164558998">

<h5 id="3-模块的作用范围应在控制范围之内。"><a href="#3-模块的作用范围应在控制范围之内。" class="headerlink" title="(3) 模块的作用范围应在控制范围之内。"></a>(3) 模块的作用范围应在控制范围之内。</h5><p>模块的控制范围包括它本身及其所有的从属模块。</p>
<p>模块的作用范围是指模块内一个判定的作用范围，凡是受这个判定影响的所有模块都属于这个判定的作用范围。</p>
<p>如果一个判定的作用范围包含在这个判定所在模块的控制范围之内，则这种结构是简单的。 </p>
<img src="/2022/05/18/software/image-20220603164618732.png" class="" title="image-20220603164618732">

<p>图(b)表明作用范围不在控制范围之内。模块G做出一个判定之后，若需要模块 C工作，则必须把信号回送给模块D，再由D把信号回送给模块B。图中加黑框表示判定的作用范围。</p>
<img src="/2022/05/18/software/image-20220603164655052.png" class="" title="image-20220603164655052">

<p>图(c)虽然表明模块的作用范围是在控制范围之内，可是判定所在模块TOP所处层次太高，这样也需要经过不必要的信号传送，增加了数据的传送量。</p>
<img src="/2022/05/18/software/image-20220603164634972.png" class="" title="image-20220603164634972">

<p>图(d) 表明作用范围在控制范围之内，只有一个判定分支有一个不必要的穿越，是一个较好的结构；</p>
<img src="/2022/05/18/software/image-20220603165055924.png" class="" title="image-20220603165055924">

<p>图(e)所示为一个比较理想的结构。</p>
<img src="/2022/05/18/software/image-20220603165100837.png" class="" title="image-20220603165100837">

<p>如果在设计过程中，发现作用范围不在控制范围内，可采用如下办法把作用范围移到控制范围之内。</p>
<p>① 将判定所在模块合并到父模块中，使判定处于较高层次。</p>
<p>② 将受判定影响的模块下移到控制范围内。</p>
<p>③ 将判定上移到层次中较高的位置。</p>
<h5 id="4-尽可能减少高扇出结构，随着深度增大扇入。"><a href="#4-尽可能减少高扇出结构，随着深度增大扇入。" class="headerlink" title="(4) 尽可能减少高扇出结构，随着深度增大扇入。"></a>(4) 尽可能减少高扇出结构，随着深度增大扇入。</h5><p>模块的扇出数是指模块调用子模块的个数。如果一个模块的扇出数过大，就意味着该模块过分复杂，需要协调和控制过多的下属模块。</p>
<p>出现这种情况是由于缺乏中间层次，所以应当适当增加中间层次的控制模块。如图所示。 </p>
<img src="/2022/05/18/software/image-20220603165146140.png" class="" title="image-20220603165146140">

<p>一个模块的扇入数越大，则共享该模块的上级模块数目越多。扇入大，是有好处的。</p>
<p>但如果一个模块的扇入数太大，如超过8，而它又不是公用模块，说明该模块可能具有多个功能。</p>
<p>在这种情况下应当对它进一步分析并将其功能分解。</p>
<img src="/2022/05/18/software/image-20220603165213083.png" class="" title="image-20220603165213083">

<h5 id="5-避免或减少使用病态连接。"><a href="#5-避免或减少使用病态连接。" class="headerlink" title="(5) 避免或减少使用病态连接。"></a>(5) 避免或减少使用病态连接。</h5><p>应限制使用如下3种病态连接。</p>
<img src="/2022/05/18/software/image-20220603165227117.png" class="" title="image-20220603165227117">

<h5 id="6-模块的大小要适中。"><a href="#6-模块的大小要适中。" class="headerlink" title="(6) 模块的大小要适中。"></a>(6) 模块的大小要适中。</h5><p>模块的大小，可以用模块中所含语句的数量的多少来衡量。</p>
<p>通常规定其语句行数为50～100，保持在一页纸之内，最多不超过500行。 </p>
<h5 id="例-银行储蓄系统"><a href="#例-银行储蓄系统" class="headerlink" title="例 银行储蓄系统"></a>例 银行储蓄系统</h5><p>1.对银行储蓄系统的数据流图进行复查并精化，得到如图所示的数据流图。</p>
<img src="/2022/05/18/software/image-20220603165308254.png" class="" title="image-20220603165308254">

<p>2.确定数据流图具有变换特性还是事务特性。通过对精化后的数据流图进行分析，可以看到整个系统是对存款及取款两种不同的事务进行处理，因此具有事务特性。</p>
<p>3.确定输入流和输出流的边界</p>
<img src="/2022/05/18/software/image-20220603165414332.png" class="" title="image-20220603165414332">

<p>4.完成第一级分解。分解后的结构图如图所示。</p>
<img src="/2022/05/18/software/image-20220603165431148.png" class="" title="image-20220603165431148">

<p>5.完成第二级分解。对上图中的“输入数据”、“输出数据”和“调度”模块进行分解，得到未经精化的输入结构、输出结构和事务结构，分别如图(a)、(b)和(c)所示。将上面的3部分合在一起，得到初始的软件结构，如图所示。</p>
<img src="/2022/05/18/software/image-20220603165515230.png" class="" title="image-20220603165515230">

<img src="/2022/05/18/software/image-20220603165536301.png" class="" title="image-20220603165536301">

<p>第6步：对软件结构进行精化。</p>
<p>(1) 由于调度模块下只有两种事务，因此，可以将调度模块合并到上级模块中，如图所示。</p>
<img src="/2022/05/18/software/image-20220603165711758.png" class="" title="image-20220603165711758">

<p>(2) “检查密码”模块的作用范围不在其控制范围之内（即“输入密码”模块不在“检查密码”模块的控制范围之内），需对其进行调整，如图所示。</p>
<img src="/2022/05/18/software/image-20220603165827354.png" class="" title="image-20220603165827354">

<p>(3) 提高模块的独立性，并对“输入事务”模块进行细化。也可以将“检查密码”功能合并到其上级模块中。</p>
<img src="/2022/05/18/software/image-20220603165855910.png" class="" title="image-20220603165855910">

<h3 id="4-4接口设计"><a href="#4-4接口设计" class="headerlink" title="4.4接口设计"></a>4.4接口设计</h3><h4 id="接口设计概述"><a href="#接口设计概述" class="headerlink" title="接口设计概述"></a>接口设计概述</h4><p>接口设计的依据是数据流图中的自动化系统边界。</p>
<p>接口设计主要包括3个方面：</p>
<ol>
<li>模块或软件构件间的接口设计；</li>
<li>软件与其他软硬件系统之间的接口设计；</li>
<li>软件与人（用户）之间的交互设计。人机交互（用户）界面是人机交互的主要方式</li>
</ol>
<h4 id="人机交互界面"><a href="#人机交互界面" class="headerlink" title="人机交互界面"></a>人机交互界面</h4><p>在设计阶段，必须根据需求把交互细节加入到用户界面设计中，包括人机交互所必须的实际显示和输入。</p>
<p>人机交互界面是给用户使用的，为了设计好人机交互界面，设计者需要了解以下信息：</p>
<p>（１）用户界面应具有的特性？</p>
<p>（２）使用软件的用户是什么人？</p>
<p>（３）用户怎样学习与新的计算机系统进行交互？</p>
<p>（４）用户需要完成哪些工作？</p>
<h5 id="用户界面应具备的特性"><a href="#用户界面应具备的特性" class="headerlink" title="用户界面应具备的特性"></a>用户界面应具备的特性</h5><p>可使用性：是用户界面设计最重要的目标．包括使用简单、界面一致、拥有help帮助功能、快速的系统响应和低的系统成本、具有容错能力等。</p>
<p>灵活性：考虑到用户的特点、能力和知识水平，应该使用户接口满足不同用户的要求。因此，对不同的用户，应有不同的界面形式，但不同的界面形式不应影响任务的完成。</p>
<p>可靠性：用户界面的可靠性是指无故障使用的间隔时间。用户界面应能保证用户正确、可靠地使用系统，保证有关程序和数据的安全性。</p>
<h5 id="用户类型"><a href="#用户类型" class="headerlink" title="用户类型"></a>用户类型</h5><p>外行型：以前从未使用过计算机系统的用户。</p>
<p>初学型：尽管对新的系统不熟悉，但对计算机还有一些使用经验的用户。</p>
<p>熟练型：对一个系统有相当多的经验，能够熟练操作的用户。</p>
<p>专家型：这一类用户了解系统内部的构造，有关于系统工作机制的专业知识，具有维护和修改基本系统的能力。专家型需要为他们提供能够修改和扩充系统能力的复杂界面。</p>
<h5 id="界面设计类型"><a href="#界面设计类型" class="headerlink" title="界面设计类型"></a>界面设计类型</h5><img src="/2022/05/18/software/image-20220603170300997.png" class="" title="image-20220603170300997">

<p>在选用界面形式的时候，应当考虑每种类型的优点和限制，可以从以下几个方面来考察：</p>
<p>(1) 使用的难易程度：对于没有经验的用户，该界面使用的难度有多大。</p>
<p>(2) 学习的难易程度：学习该界面的命令和功能的难度有多大。</p>
<p>(3) 操作速度：在完成一个指定操作时，该界面在操作步骤、击键和反应时间等方面效率有多高。</p>
<p>(4) 复杂程度：该界面提供了什么功能、能否用新的方式组合这些功能以增强界面的功能。</p>
<p>(5) 控制：人机交互时，是由计算机还是由人发起和控制对话。</p>
<p>(6) 开发的难易程度：该界面设计是否有难度、开发工作量有多大。</p>
<h5 id="设计详细的交互"><a href="#设计详细的交互" class="headerlink" title="设计详细的交互"></a>设计详细的交互</h5><p>人机交互的设计有若干准则，包括以下内容：</p>
<p>(1) 一致性。采用一致的术语、一致的步骤和一致的活动。</p>
<p>(2) 操作步骤少。使击键或点击鼠标的次数减到最少，甚至要减少做某些事所需的下拉菜单的距离。</p>
<p>(3) 不要“哑播放”。</p>
<p>(4) 提供Undo功能。</p>
<p>(5) 减少人脑的记忆负担。不应该要求人从一个窗口中记住某些信息，然后在另一个窗口中使用。</p>
<p>(6) 提高学习效率。为高级特性提供联机帮助，以便用户在需要时容易找到。</p>
<h3 id="4-5数据设计"><a href="#4-5数据设计" class="headerlink" title="4.5数据设计"></a>4.5数据设计</h3><h4 id="文件设计"><a href="#文件设计" class="headerlink" title="文件设计"></a>文件设计</h4><p>以下几种情况适合于选择文件存储。</p>
<p>(1) 数据量较大的非结构化数据，如多媒体信息。</p>
<p>(2) 数据量大，信息松散，如历史记录、档案文件等。</p>
<p>(3) 非关系层次化数据，如系统配置文件。</p>
<p>(4) 对数据的存取速度要求极高的情况。</p>
<p>(5) 临时存放的数据。</p>
<p>一般要根据文件的特性，来确定文件的组织方式。</p>
<p>(1) 顺序文件：这类文件分两种，一种是连续文件，另一种是串联文件。  </p>
<p>(2) 直接存取文件：可根据记录关键字的值，通过计算直接得到记录的存放地址。</p>
<p>(3) 索引顺序文件：其基本数据记录按顺序文件组织，记录排列顺序必须按关键字值升序或降序安排，且具有索引部分，索引部分也按同一关键字进行索引。 </p>
<p>(4) 分区文件：这类文件主要用于存放程序。它由若干称为成员的顺序组织的记录组和索引组成。每一个成员就是一个程序，由于各个程序的长度不同，所以各个成员的大小也不同，需要利用索引给出各个成员的程序名、开始存放位置和长度。 </p>
<p>(5) 虚拟存储文件：这是基于操作系统的请求页式存储管理功能而建立的索引顺序文件。 </p>
<h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>根据数据库的组织，可以将数据库分为网状数据库、层次数据库、关系数据库、面向对象数据库、文档数据库、多维数据库等。</p>
<p>关系数据库最成熟，应用也最广泛，一般情况下，大多数设计者都会选择关系数据库。</p>
<p>在结构化设计方法中，很容易将结构化分析阶段建立的实体—关系模型映射到关系数据库中。  </p>
<h5 id="数据对象实体的映射"><a href="#数据对象实体的映射" class="headerlink" title="数据对象实体的映射"></a>数据对象实体的映射</h5><p>一个数据对象（实体）可以映射为一个表或多个表，当分解为多个表时，可以采用横切和竖切的方法。</p>
<p>竖切常用于实例较少而属性很多的对象。通常将经常使用的属性放在主表中，而将其他一些次要的属性放到其他表中。</p>
<p>横切常常用于记录与时间相关的对象。往往在主表中只记录最近的对象，而将以前的记录转到对应的历史表中。</p>
<h5 id="关系的映射"><a href="#关系的映射" class="headerlink" title="关系的映射"></a>关系的映射</h5><p>一对一关系的映射：可以在两个表中都引入外键，进行双向导航。也可以将两个数据对象组合成一张单独的表。</p>
<p>一对多关系的映射：可以将关联中的“一”端毫无变化地映射到一张表，将关联中表示“多”的端上的数据对象映射到带有外键的另一张表，使外键满足关系引用的完整性。</p>
<p>多对多关系的映射：为了表示多对多关系，关系模型必须引入一个关联表，将两个数据实体之间的多对多关系转换成两个一对多关系。</p>
<h3 id="4-6过程设计"><a href="#4-6过程设计" class="headerlink" title="4.6过程设计"></a>4.6过程设计</h3><p>表达过程规格说明的工具称为过程描述工具，可以将过程描述工具分为以下3类。</p>
<p>(1) 图形工具：把过程的细节用图形方式描述出来，如程序流程图、N-S图、PAD图、决策树等。</p>
<p>(2) 表格工具：用一张表来表达过程的细节。这张表列出了各种可能的操作及其相应的条件，即描述了输入、处理和输出信息，如决策表。</p>
<p>(3) 语言工具：用某种类高级语言（称为伪代码）来描述过程的细节，如很多数据结构教材中使用类Pascal、类C语言来描述算法。</p>
<h4 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h4><p>最早由E. W. Dijkstra提出;建议从高级语言中取消GOTO语句；1966年，Bohm和Jacopini证明：只用三种基本的控制结构“顺序”、“选择”和“循环”就能实现任何单入口和单出口的没有“死循环”的程序。</p>
<p>概念：如果一个程序的代码块仅仅通过顺序、选择和循环这三种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。</p>
<p>结构程序设计的主要原则</p>
<p>(1)使用语言中的顺序、选择、重复等有限的基本控制结构表示程序逻辑。</p>
<p>(2)选用的控制结构只准许有一个入口和一个出口。</p>
<p>(3)程序语句组成容易识别的块（Block），每块只有一个入口和一个出口。</p>
<p>(4)复杂结构应该用基本控制结构进行组合嵌套来实现。</p>
<p>(5)语言中没有的控制结构，可用一段等价的程序段模拟， 但要求该程序段在整个系统中应前后一致。</p>
<p>(6) 严格控制GOTO语句，仅在下列情形才可使用：</p>
<p>用非结构化的程序设计语言去实现结构化的构造。</p>
<p>若不使用GOTO语句就会使程序功能模糊。</p>
<p>在某种可以改善而不是损害程序可读性的情况下。例如，在查找结束时，文件访问结束时，出现错误情况要从循环中转出时，使用布尔变量和条件结构来实现就不如用GOTO语句来得简洁易懂。</p>
<p>(7) 在程序设计过程中，尽量采用自顶向下(Top－Down)、逐步细化(Stepwise Refinement)的原则，由粗到细，一步步展开。</p>
<h4 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h4><p>程序流程图也称为程序框图，是软件开发者最熟悉的算法表达工具。</p>
<p>早期的流程图也存在一些缺点。特别是表示程序控制流程的箭头，使用的灵活性极大，程序员可以不受任何约束，随意转移控制，这将不符合结构化程序设计的思想。</p>
<p>为使用流程图描述结构化程序，必须对流程图加以限制。</p>
<p>程序流程图的基本控制结构</p>
<p>(1) 顺序型：几个连续的加工步骤依次排列构成。</p>
<p>(2) 选择型：由某个逻辑判断式的取值决定选择两个加工中的一个。</p>
<p>(3) 先判定（while）型循环：在循环控制条件成立时，重复执行特定的加工。</p>
<p>(4) 后判定（until）型循环：重复执行某些特定的加工，直至控制条件成立。</p>
<p>(5) 多情况（case）型选择：列举多种加工情况，根据控制变量的取值，选择执行其一。</p>
<p>基本控制结构</p>
<img src="/2022/05/18/software/image-20220603171046082.png" class="" title="image-20220603171046082">

<img src="/2022/05/18/software/image-20220603171053365.png" class="" title="image-20220603171053365">

<p>符号</p>
<img src="/2022/05/18/software/image-20220603171100021.png" class="" title="image-20220603171100021">

<p>循环标准符号</p>
<img src="/2022/05/18/software/image-20220603171129259.png" class="" title="image-20220603171129259">

<p>注释符号使用</p>
<img src="/2022/05/18/software/image-20220603171141332.png" class="" title="image-20220603171141332">

<p>多选择判断</p>
<img src="/2022/05/18/software/image-20220603171235164.png" class="" title="image-20220603171235164">

<h4 id="N-S图"><a href="#N-S图" class="headerlink" title="N-S图"></a>N-S图</h4><p>Nassi和Shneiderman 提出了一种符合结构化程序设计原则的图形描述工具，叫做盒图 （box-diagram），也叫做N-S图。</p>
<p>在N-S图中，为了表示5种基本控制结构，规定了5种图形构件。</p>
<img src="/2022/05/18/software/image-20220603171322961.png" class="" title="image-20220603171322961">

<img src="/2022/05/18/software/image-20220603171326493.png" class="" title="image-20220603171326493">

<h4 id="PAD图"><a href="#PAD图" class="headerlink" title="PAD图"></a>PAD图</h4><p>PAD（problem analysis diagram）是日本日立公司提出，由程序流程图演化来的，用结构化程序设计思想表现程序逻辑结构的图形工具。</p>
<p>PAD也设置了5种基本控制结构的图式，并允许递归使用。</p>
<img src="/2022/05/18/software/image-20220603171352726.png" class="" title="image-20220603171352726">

<img src="/2022/05/18/software/image-20220603171357563.png" class="" title="image-20220603171357563">

<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><p>伪代码是一种介于自然语言和形式化语言之间的半形式化语言，是一种用于描述功能模块的算法设计和加工细节的语言，也称为程序设计语言（Program Design Language，PDL）。</p>
<p>伪码的语法规则分为“外语法”和“内语法”。</p>
<p>外语法应当符合一般程序设计语言常用语句的语法规则；</p>
<p>内语法可以用英语中一些简单的句子、短语和通用的数学符号来描述程序应执行的功能。</p>
<p>简单陈述句结构：避免复合语句。</p>
<p>判定结构：IF_THEN_ELSE或CASE_OF结构。</p>
<p>重复结构：WHILE_DO或REPEAT_UNTIL结构。</p>
<img src="/2022/05/18/software/image-20220603171513748.png" class="" title="image-20220603171513748">

<p>(1) 有固定的关键字外语法，提供全部结构化控制结构、数据说明和模块特征。外语法的关键字是有限的词汇集，它们能对伪代码正文进行结构分割，使之变得易于理解。</p>
<p>(2) 内语法使用自然语言来描述处理特性，为开发者提供方便，提高可读性。</p>
<p>(3) 有数据说明机制，包括简单的（如标量和数组）与复杂的（如链表和层次结构）的数据结构。</p>
<p>(4) 有子程序定义与调用机制，用以表达各种方式的接口说明。</p>
<h4 id="自顶向下、逐步细化的设计过程"><a href="#自顶向下、逐步细化的设计过程" class="headerlink" title="自顶向下、逐步细化的设计过程"></a>自顶向下、逐步细化的设计过程</h4><p>主要包括两个方面：</p>
<p>一是将复杂问题的解法分解和细化成由若干个模块组成的层次结构；</p>
<p>二是将每个模块的功能逐步分解细化为一系列的处理。</p>
<p>在处理较大的复杂任务时，常采取“模块化”的方法，即在程序设计时不是将全部内容都放在同一个模块中，而是分成若干个模块，每个模块实现一个功能。</p>
<p>模块分解完成后，下一步的任务就是将每个模块的功能逐步分解细化为一系列的处理。</p>
<p>在概要设计阶段，我们已经采用自顶向下、逐步细化的方法，把复杂问题的解法分解和细化成了由许多功能模块组成的层次结构的软件系统。</p>
<p>在详细设计和编码阶段，我们还应当采取自顶向下、逐步求精的方法，把模块的功能逐步分解，细化为一系列具体的步骤，进而翻译成一系列用某种程序设计语言写成的程序。</p>
<p>自顶向下、逐步细化方法举例</p>
<p>用筛选法求100以内的素数。所谓的筛选法，就是从2到100中去掉2,3,5,7的倍数，剩下的就是100以内的素数。</p>
<p>1.首先按程序功能写出一个框架</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">main （） &#123; <br> 建立<span class="hljs-number">2</span>到<span class="hljs-number">100</span>的数组A[ ]，其中A[i]＝i；- - - - - <span class="hljs-number">1</span> <br> 建立<span class="hljs-number">2</span>到<span class="hljs-number">10</span>的素数表B[ ]，存放<span class="hljs-number">2</span>到<span class="hljs-number">10</span>以内的素数；- - <span class="hljs-number">2</span><br> 若A[i]＝i是B[ ]中任一数的倍数，则剔除A[i]； - - <span class="hljs-number">3</span> <br> 输出A[ ]中所有没有被剔除的数； - - - - - - - <span class="hljs-number">4</span> <br> &#125; <br></code></pre></td></tr></table></figure>

<p>2.上述框架中每一个加工语句都可进一步细化成一个循环语句 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">main （） &#123;<br>   <span class="hljs-comment">/*建立2到100的数组A[ ]，其中A[i]＝i*/</span>    - -  <span class="hljs-number">1</span><br>   <span class="hljs-keyword">for</span> （i = <span class="hljs-number">2</span>；i &lt;= <span class="hljs-number">100</span>；i++）A[i] = i；<br>   <span class="hljs-comment">/* 建立2到10的素数表B[ ]，存放2到10以内的素数*/</span>  - <span class="hljs-number">2</span><br>   B[<span class="hljs-number">1</span>] =<span class="hljs-number">2</span>；  B[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>；  B[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>；  B[<span class="hljs-number">4</span>] = <span class="hljs-number">7</span>；<br>   <span class="hljs-comment">/*若A[i]＝i是B[ ]中任一数的倍数，则剔除A[i]*/</span>  - - <span class="hljs-number">3</span><br>   <span class="hljs-keyword">for</span> （j = <span class="hljs-number">1</span>； j &lt;= <span class="hljs-number">4</span>； j++）<br>     检查A[ ]所有的数能否被B[j]整除并将能被整除的数从A[]中剔除； <br>   <span class="hljs-comment">/*输出A[ ]中所有没有被剔除的数*/</span>   - - - - - - - <span class="hljs-number">4</span><br>   <span class="hljs-keyword">for</span> （i = <span class="hljs-number">2</span>； i &lt;= <span class="hljs-number">100</span>； i++）<br>     若A[i]没有被剔除，则输出之<br> &#125;<br><br></code></pre></td></tr></table></figure>

<p>自顶向下、逐步求精的方法的优点 </p>
<p>(1) 自顶向下、逐步求精方法符合人们解决复杂问题的普遍规律。可提高软件开发的成功率和生产率。</p>
<p>(2) 用先全局后局部，先整体后细节，先抽象后具体的逐步求精的过程开发出来的程序具有清晰的层次结构，因此程序容易阅读和理解。</p>
<p>(3) 程序自顶向下、逐步细化，分解成树形结构。 在同一层的结点上做细化工作，相互之间没有关系，因此它们之间的细化工作相互独立。在任何一步发生错误，一般只影响它下层的结点，同一层的其他结点不受影响。 </p>
<p>(4) 程序清晰和模块化，使得在修改和重新设计一个软件时，可复用的代码量最大。</p>
<p>(5) 程序的逻辑结构清晰，有利于程序正确性证明。</p>
<p>(6) 每一步工作仅在上层结点的基础上做不多的设计扩展，便于检查。</p>
<p>(7) 有利于设计的分工和组织工作。</p>
<h3 id="4-7软件设计规格说明"><a href="#4-7软件设计规格说明" class="headerlink" title="4.7软件设计规格说明"></a>4.7软件设计规格说明</h3><p>国家标准GB/T 8567—2006《计算机软件文档编制规范》中有关软件总体设计的文档是《系统/子系统设计（结构设计）说明（SSDD）》， 描述了系统或子系统的系统级或子系统级设计与体系结构设计。 </p>
<h3 id="4-8软件设计评审"><a href="#4-8软件设计评审" class="headerlink" title="4.8软件设计评审"></a>4.8软件设计评审</h3><h1 id="Part3-面向对象分析与设计方法"><a href="#Part3-面向对象分析与设计方法" class="headerlink" title="Part3.面向对象分析与设计方法"></a>Part3.面向对象分析与设计方法</h1><h2 id="5-面向对象方法与UML"><a href="#5-面向对象方法与UML" class="headerlink" title="5.面向对象方法与UML"></a>5.面向对象方法与UML</h2><h3 id="5-1面向对象的概念与开发方法"><a href="#5-1面向对象的概念与开发方法" class="headerlink" title="5.1面向对象的概念与开发方法"></a>5.1面向对象的概念与开发方法</h3><p>面向对象的定义：面向对象＝对象＋类＋继承＋消息通信</p>
<p>如果一个系统是使用这样4个概念设计和实现的，则可认为这个系统是面向对象的。</p>
<h4 id="1-对象"><a href="#1-对象" class="headerlink" title="1.对象"></a>1.对象</h4><p>对象是包含现实世界物体特征的抽象实体，它反映了系统为之保存信息和（或）与它交互的能力。</p>
<p>例如，Student对象的数据可能有姓名、性别、出生日期、家庭住址、电话号码等，其操作可能是对这些数据值的赋值及更改。</p>
<img src="/2022/05/18/software/image-20220520095244946.png" class="" title="image-20220520095244946">

<p>对象名有下列三种表示格式：</p>
<p>(1) 第一种格式是对象名在前，类名在后，中间用冒号连接。形如：</p>
<p>​      <u>对象名：类名</u></p>
<p>(2) 第二种格式形如：</p>
<p>​      <u>：类名</u></p>
<p> 这种格式用于尚未给对象命名的情况，注意，类名前的冒号不能省略。</p>
<p>(3) 第三种格式形如：</p>
<p>​      <u>对象名</u></p>
<p>对象有两个层次的概念：</p>
<p>(1) 现实生活中对象指的是客观世界的实体。可以是可见的有形对象，如人、学生、汽车、房屋等；也可以是抽象的逻辑对象，如银行帐号，生日。</p>
<p>(2) 程序中对象就是一组变量和相关方法的集合，其中变量表明对象的状态，方法表明对象所具有的行为。</p>
<p>可以将程序中的对象分为5类：物理对象，角色，事件，交互，规格说明。</p>
<ol>
<li><p><strong>物理对象</strong>（Physical Objects）── 物理对象是最易识别的对象，通常可以在问题领域的描述中找到，它们的属性可以标识和测量。</p>
<p>例如，大学课程注册系统中的学生对象；一个网络管理系统中各种网络物理资源对象（如开关、CPU和打印机）都是物理对象。</p>
</li>
<li><p><strong>角色</strong>（Roles）── 一个实体的角色也可以抽象成一个单独的对象。角色对象的操作是由角色提供的技能。</p>
<p>例如，一个退休教师同时扮演退休者和教师的角色。</p>
</li>
<li><p> <strong>事件</strong>（Events）── 一个事件是某种活动的一次“出现”。</p>
</li>
</ol>
<p>   例如“鼠标”事件。一个事件对象通常是一个数据实体，它管理“出现”的重要信息。事件对象的操作主要用于对数据的存取。</p>
<ol start="4">
<li><p><strong>交互</strong>（Interactions）── 交互表示了在两个对象之间的关系，这种类型的对象类似于在数据库设计时所涉及的“关系”实体。当实体之间是多对多的关系时，利用交互对象可将其简化为两个一对多的关系。</p>
<p>例如，在大学课程注册系统中，学生和课程之间的关系是多对多的关系，可设置一个“选课”交互对象来简化它们之间的关系。</p>
</li>
<li><p><strong>规格说明</strong>（specification）规格说明对象表名组合某些实体时的要求。</p>
</li>
</ol>
<h4 id="2-类与封装"><a href="#2-类与封装" class="headerlink" title="2.类与封装"></a>2.类与封装</h4><p>类</p>
<p>可以将现实生活中的对象经过抽象，映射为程序中的对象。对象在程序中是通过一种抽象数据类型来描述的，这种抽象数据类型称为类（Class）。 </p>
<p>为了让计算机创建对象，必须先提供对象的定义，也就是先定义对象所属的类。例如，可以将学生对象所属的类定义为Student。类的图形表示如图所示。</p>
<img src="/2022/05/18/software/image-20220520100441732.png" class="" title="image-20220520100441732">

<p>封装</p>
<p>面向对象的封装特性与其抽象特性密切相关。封装是一种信息隐蔽技术，就是利用抽象数据类型将数据和基于数据的操作封装在一起。用户只能看到对象的封装界面信息，对象的内部细节对用户是隐蔽的。</p>
<p>封装的定义是：</p>
<p>(1) 清楚的边界，所有对象的内部信息被限定在这个边界内；</p>
<p>(2) 接口，即对象向外界提供的方法，外界可以通过这些方法与对象进行交互；</p>
<p>(3) 受保护的内部实现，即软件对象功能的实现细节，实现细节不能从类外访问。</p>
<h4 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h4><p>继承是一种联结类的层次模型，为类的重用提供了方便，它提供了明确表述不同类之间共性的方法。</p>
<h4 id="4-多态"><a href="#4-多态" class="headerlink" title="4.多态"></a>4.多态</h4><p>根据为请求提供服务的对象不同可以得到不同的行为，这种现象称为多态。通过在子类中覆盖父类的方法实现多态。</p>
<h4 id="5-消息通信"><a href="#5-消息通信" class="headerlink" title="5.消息通信"></a>5.消息通信</h4><p>消息是一个对象与另一个对象的通信单元，是要求某个对象执行类中定义的某个操作的规格说明。</p>
<p>发送给一个对象的消息定义了一个方法名和一个参数表（可能是空的），并指定某一个对象。</p>
<p>一个对象接收到消息，则调用消息中指定的方法，并将形式参数与参数表中相应的值结合起来。</p>
<h4 id="6-面向对象软件开发方法"><a href="#6-面向对象软件开发方法" class="headerlink" title="6.面向对象软件开发方法"></a>6.面向对象软件开发方法</h4><p>方法的唯一性：即方法是对软件开发过程所有阶段进行综合考虑而得到的。</p>
<p>从生存期的一个阶段到下一个阶段的高度连续性，即生存期后一阶段的成果只是在前一阶段成果的补充和修改。</p>
<p>将面向对象分析(OOA)、面向对象设计(OOD)和面向对象程序设计(OOP)集成到生存期的相应阶段。</p>
<h5 id="Booch方法"><a href="#Booch方法" class="headerlink" title="Booch方法"></a>Booch方法</h5><p>包含“微开发过程”和“宏开发过程”两个过程。OOA 宏观开发过程如下：</p>
<p>标识类和对象；标识类和对象的语义；标识类和对象间的关系；进行一系列精化；实现类和对象。</p>
<h5 id="Rumbaugh方法"><a href="#Rumbaugh方法" class="headerlink" title="Rumbaugh方法"></a>Rumbaugh方法</h5><p> Rumbaugh和他的同事提出的对象模型化技术(OMT)用于分析、系统设计和对象级设计。分析活动建立三个模型：</p>
<p>对象模型(描述对象、类、层次和关系)；动态模型(描述对象和系统的行为)；功能模型(类似于高层的DFD，描述穿越系统的信息流)。</p>
<h5 id="Coad和Yourdon方法"><a href="#Coad和Yourdon方法" class="headerlink" title="Coad和Yourdon方法"></a>Coad和Yourdon方法</h5><p> Coad和Yourdon方法常常被认为是最容易学习的OOA方法。建模符号相当简单，其OOA过程如下：</p>
<p>(1) 使用“要找什么”准则标识对象；</p>
<p>(2) 定义对象之间的一般化/特殊化结构（又称为分类结构）；</p>
<p>(3) 定义对象之间的整体/部分结构（又称为组合结构）； </p>
<p>(4) 标识主题；</p>
<p>(5) 定义对象的属性及对象之间的实例连接；</p>
<p>(6) 定义服务及对象之间的消息连接。</p>
<h5 id="Jacobson方法"><a href="#Jacobson方法" class="headerlink" title="Jacobson方法"></a>Jacobson方法</h5><p>也称为OOSE(面向对象软件工程)，其特点是特别强调使用用例——用以描述用户和产品或系统间如何交互的场景。过程如下：</p>
<p>标识系统的用户和他们的整体责任；构造需求模型；构造分析模型 。</p>
<h3 id="5-2UML简介"><a href="#5-2UML简介" class="headerlink" title="5.2UML简介"></a>5.2UML简介</h3><p>统一建模语言(UML，Unified Modeling Language)；</p>
<p>它将Booch、Rumbaugh和Jacobson等各自独立的OOA和OOD方法中最优秀的特色组合成一个统一的方法。</p>
<h4 id="1-UML特点"><a href="#1-UML特点" class="headerlink" title="1.UML特点"></a>1.UML特点</h4><ol>
<li>统一标准</li>
<li>面向对象</li>
<li>可视化，表达能力强大</li>
<li>独立于过程</li>
<li>容易掌握使用</li>
<li>与编程语言的关系</li>
</ol>
<h4 id="2-UML基本模型"><a href="#2-UML基本模型" class="headerlink" title="2.UML基本模型"></a>2.UML基本模型</h4><p>UML符号为开发者或开发工具使用这些图形符号和文本语法为系统建模提供了标准。这些图形符号和文字所表达的是应用级的模型，在语义上它是UML元模型的实例。UML模型由事物、关系和图组成 。 </p>
<img src="/2022/05/18/software/image-20220520101945101.png" class="" title="image-20220520101945101">

<h3 id="5-3UML事物"><a href="#5-3UML事物" class="headerlink" title="5.3UML事物"></a>5.3UML事物</h3><p>事物是对模型中最具代表性成分的抽象，在UML中，可以分为结构事物、行为事物、分组事物和注释事物4类。 </p>
<img src="/2022/05/18/software/image-20220520102017668.png" class="" title="image-20220520102017668">

<h4 id="1-结构事物"><a href="#1-结构事物" class="headerlink" title="1.结构事物"></a>1.结构事物</h4><p>结构事物是UML模型的静态部分，主要用来描述概念的或物理的元素，包括类、主动类、接口、对象、用例、参与者、协作、构件和节点等。</p>
<ol>
<li><p>类（class）── 类用带有类名、属性和操作的矩形框来表示。</p>
</li>
<li><p>主动类（active class）── 主动类的实例应具有一个或多个进程或线程，能够启动控制活动。</p>
</li>
<li><p>接口（interface）── 描述了一个类或构件的一组外部可用的服务（操作）集。</p>
<p>接口定义的是一组操作的描述，而不是操作的实现。 一般将接口画成从实现它的类或构件引出的圆圈，接口体现了使用与实现分离的原则。</p>
</li>
<li><p>对象（object）── 对象是类的实例，其名字下边加下划线，对象的属性值需明确给出。</p>
</li>
<li><p>用例（use case）── 也称用况，用于表示系统想要实现的行为，即描述一组动作序列（即场景）。而系统执行这组动作后将产生一个对特定参与者有价值的结果。</p>
</li>
<li><p>参与者（actor）── 也称角色，是指与系统有信息交互关系的人、软件系统或硬件设备，在图形上用简化的小木头人表示。</p>
</li>
<li><p>协作（collaboration）── 用例仅描述要实现的行为，不描述这些行为的实现。这种实现用协作描述。</p>
<p>协作定义交互，描述一组角色实体和其他实体如何通过协同工作来完成一个功能或行为。类可以参与几个协作。</p>
</li>
<li><p>构件（component）── 也称组件，是系统中物理的、可替代的部件。它通常是描述一些逻辑元素的物理包。</p>
</li>
<li><p>节点（node）── 是在运行时存在的物理元素。它代表一种可计算的资源，通常具有一定的记忆能力和处理能力。</p>
</li>
</ol>
<h4 id="2-行为事物"><a href="#2-行为事物" class="headerlink" title="2.行为事物"></a>2.行为事物</h4><p>行为事物是UML模型的动态部分，包括两类：</p>
<ol>
<li><p>交互（interaction）── 交互由在特定的上下文环境中共同完成一定任务的一组对象之间传递的消息组成。如图所示。交互涉及的元素包括消息、动作序列（由一个消息所引起的行为）和链（对象间的连接）。</p>
<img src="/2022/05/18/software/image-20220520102433994.png" class="" title="image-20220520102433994"></li>
<li><p>状态机（state machine）── 描述了一个对象或一个交互在生存周期内响应事件所经历的状态序列，单个类或者一组类之间协作的行为都可以用状态机来描述。状态机涉及到状态、变迁和活动，其中状态用圆角矩形来表示。</p>
<img src="/2022/05/18/software/image-20220520102538708.png" class="" title="image-20220520102538708"></li>
</ol>
<h4 id="3-分组事物"><a href="#3-分组事物" class="headerlink" title="3.分组事物"></a>3.分组事物</h4><p>分组事物是UML模型的组织部分。它的作用是为了降低模型复杂性。</p>
<p>UML中的分组事物是包（package）。</p>
<p>包是把模型元素组织成组的机制，结构事物、行为事物甚至其他分组事物都可以放进包内。</p>
<img src="/2022/05/18/software/image-20220520102605149.png" class="" title="image-20220520102605149">

<h4 id="4-注释事物"><a href="#4-注释事物" class="headerlink" title="4.注释事物"></a>4.注释事物</h4><p>注释事物是UML模型的解释部分，它们用来描述和标注模型的任何元素。</p>
<p>通常可以用注释修饰带有约束或者解释的图。</p>
<img src="/2022/05/18/software/image-20220520102629220.png" class="" title="image-20220520102629220">

<h3 id="5-4UML关系"><a href="#5-4UML关系" class="headerlink" title="5.4UML关系"></a>5.4UML关系</h3><img src="/2022/05/18/software/image-20220520102638588.png" class="" title="image-20220520102638588">

<h4 id="1-依赖关系"><a href="#1-依赖关系" class="headerlink" title="1.依赖关系"></a>1.依赖关系</h4><p>依赖(Dependency)是两个事物之间的语义关系，其中一个事物发生变化会影响到另一个事物的语义，它用一个虚线箭头表示。</p>
<p>虚线箭头的方向从源事物指向目标事物，表示源事物依赖于目标事物。</p>
<img src="/2022/05/18/software/image-20220520103017732.png" class="" title="image-20220520103017732">CourseSchedule依赖Course

<img src="/2022/05/18/software/image-20220520103026022.png" class="" title="image-20220520103026022">

<img src="/2022/05/18/software/image-20220520103154412.png" class="" title="image-20220520103154412">

<h4 id="2-关联关系"><a href="#2-关联关系" class="headerlink" title="2.关联关系"></a>2.关联关系</h4><p>关联(association)是一种结构关系，它描述了两个或多个类的实例之间的连接关系，是一种<strong>特殊的依赖</strong>。</p>
<h5 id="普通关联"><a href="#普通关联" class="headerlink" title="普通关联"></a>普通关联</h5><p>普通关联是最常见的关联关系，只要类与类之间存在连接关系就可以用普通关联表示。普通关联又分为二元关联和多元关联。</p>
<p>二元关联描述两个类之间的关联，用两个类之间的一条直线来表示，直线上可写上关联名，并用实心三角指示关联名指的是哪一个方向。如果关联含义清晰的话可以不写。如图先生类和学徒类之间的关联，该关联表明一位先生教授多名学徒，这些学徒受教于一位先生。</p>
<img src="/2022/05/18/software/image-20220520103233355.png" class="" title="image-20220520103233355">

<p>关联与两端的类连接的地方叫关联端点，在关联两端连接的类各自充当了某种角色，有关的信息（角色名、可见性、多重性等）可附加到各个端点上。</p>
<p>多重性（multiplicity）：多重性表明在一个关联的两端连接的类实例个数的对应关系，即一端的类的多少个实例对象可以与另一端的类的一个实例相关。如果图中没有明确标出关联的多重性，则默认的多重性为1</p>
<img src="/2022/05/18/software/image-20220520103903516.png" class="" title="image-20220520103903516">

<p>角色：关联端点上还可以附加角色名，表示类的实例在这个关联中扮演的角色（驾驶员、运输车）。</p>
<img src="/2022/05/18/software/image-20220520104037278.png" class="" title="image-20220520104037278">

<p>UML还允许一个类与它自身关联。航班与乘务组是多对多的关联，乘务长与乘务员是1对多的关联，乘务长与乘务员之间存在管理关系。</p>
<img src="/2022/05/18/software/image-20220520104039475.png" class="" title="image-20220520104039475">



<h5 id="多元关联"><a href="#多元关联" class="headerlink" title="多元关联"></a>多元关联</h5><p>多元关联是指3个或3个以上类之间的关联。</p>
<p>多元关联由一个菱形，以及由菱形引出的通向各个相关类的直线组成，关联名可标在菱形的旁边，在关联的端点也可以标上多重性等信息。</p>
<p>图表示哪个程序员用哪种程序语言开发了哪个项目</p>
<img src="/2022/05/18/software/image-20220520104107005.png" class="" title="image-20220520104107005">



<h5 id="限定关联"><a href="#限定关联" class="headerlink" title="限定关联"></a>限定关联</h5><p>限定关联通常用在一对多或多对多的关联关系中，可以把模型中的多重性从一对多变成一对一，或将多对多简化成多对一。</p>
<p>在类图中把限定词（qualifier）放在关联关系末端的一个小方框内。</p>
<p>例如,某操作系统中一个目录下有许多文件,一个文件仅属于一个目录,在一个目录内文件名确定了唯一的一个文件。利用限定词“文件名”表示了目录与文件之间的关系,这样就利用限定词把一对多关系简化成了一对一关系。注意,限定词“文件名”应该放在靠近目录的那一端。</p>
<img src="/2022/05/18/software/image-20220520104439375.png" class="" title="image-20220520104439375">



<h5 id="关联类"><a href="#关联类" class="headerlink" title="关联类"></a>关联类</h5><p>在关联关系比较简单的情况下，关联关系的语义用关联关系的名字来概括。但在某些情况下，需要对关联关系的语义做详细的定义、存储和访问，为此可以建立关联类（association class），用来描述关联的属性。关联中的每个链与关联类的一个实例相联系。关联类通过一条虚线与关联连接。</p>
<p>如图是一个公司类与属下一个或多个员工之间的关联，通过关联类给出关联“job”的细节。</p>
<img src="/2022/05/18/software/image-20220520105405540.png" class="" title="image-20220520105405540">



<h5 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h5><p>聚合（Aggregation）也称为聚集，是一种特殊的关联。它描述了整体和部分之间的结构关系。</p>
<p>两种特殊的聚合关系：共享聚合（shared aggregation）和复合聚合（composition aggregation）。</p>
<ol>
<li><p>如果在聚合关系中处于部分方的实例可同时参与多个处于整体方实例的构成，则该聚合称为共享聚合。 </p>
<img src="/2022/05/18/software/image-20220520105555283.png" class="" title="image-20220520105555283"></li>
<li><p>如果部分类完全隶属于整体类，部分类需要与整体类共存，一旦整体类不存在了，则部分类也会随之消失，或失去存在价值，则这种聚合称为复合聚合。 </p>
<img src="/2022/05/18/software/image-20220520105638179.png" class="" title="image-20220520105638179"></li>
</ol>
<h5 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h5><p>导航（navigability）是关联关系的一种特性，它通过在关联的一个端点上加箭头来表示导航的方向。导航主要在设计阶段使用，当关联具有双向可导航性时，可以省略指示导航方向的箭头，此时隐指双向可导航。</p>
<p>在图a所示的关联中，课程与学生之间是多对多的关系，这个关联的链由一组 (课程实例，学生实例）对组成的元组组成。如果想知道某门课程有哪些学生选修，或某个学生选修了哪些课程，就需遍历该链的所有元组。UML通过在关联端点加一个箭头来表示导航，导航能从该链的所有元组中得到给定的元组。</p>
<p>例如，图b给出的学生和课程之间的导航表明，当指定一门课程时，就能直接导航出选修这门课程的所有学生，不用遍历全部元组，但当指定一个学生时，不能直接导航出该学生选修的所有课程，只能通过遍历全部元组才能得到结果。这种导航是单向的。</p>
<p>同样，图c给出了学生到课程的（单向）导航，即当指定一个学生时就能直接导航出该学生所选的所有课程。</p>
<p>图d则表示学生与课程之间的导航是双向。</p>
<img src="/2022/05/18/software/image-20220520105749517.png" class="" title="image-20220520105749517">



<h4 id="3-泛化关系"><a href="#3-泛化关系" class="headerlink" title="3.泛化关系"></a>3.泛化关系</h4><p>•泛化(generalization)关系就是一般类和特殊类之间的继承关系。</p>
<p>•在UML中，一般类亦称泛化类，特殊类亦称特化类。</p>
<p>•泛化针对类型而不针对实例，因为一个类可以继承另一个类，但一个对象不能继承另一个对象。</p>
<h5 id="普通泛化"><a href="#普通泛化" class="headerlink" title="普通泛化"></a>普通泛化</h5><p>普通泛化与前面讲过的继承基本相同。但在泛化关系中常遇到抽象类。一般称没有具体对象的类为抽象类。抽象类通常作为父类，用于描述其他类（子类）的公共属性和行为。</p>
<p>在图形上，抽象类的类名下附加一个标签值{abstract}，如图所示。下方的两个折角矩形是注释，分别说明了两个子类的drive操作功能。抽象类中的操作用于指定它的所有具体子类应具有的行为。这些操作在每个具体子类中有具体的实现。每一个具体子类可创建自己的实例。</p>
<img src="/2022/05/18/software/image-20220520111932137.png" class="" title="image-20220520111932137">

<p>•普通泛化可以分为多重继承和单继承。多重继承是指一个子类可同时继承多个上层父类。</p>
<img src="/2022/05/18/software/image-20220520112446593.png" class="" title="image-20220520112446593">

<h5 id="受限泛化"><a href="#受限泛化" class="headerlink" title="受限泛化"></a>受限泛化</h5><p>•受限泛化关系是指泛化具有约束条件。</p>
<p>一般有4种约束：交叠（overlapping）、不相交（disjoint）、完全（complete）和不完全（incomplate）</p>
<img src="/2022/05/18/software/image-20220520112530852.png" class="" title="image-20220520112530852">

<h4 id="4-实现关系"><a href="#4-实现关系" class="headerlink" title="4.实现关系"></a>4.实现关系</h4><p>•实现(implement)是泛化关系和依赖关系的结合，也是类之间的语义关系，通常在以下两种情况出现实现关系：</p>
<p>(1)接口和实现它们的类或构件之间；</p>
<p>(2)用例和实现它们的协作之间。</p>
<p>图用TV类和Radio类来实现接口ElectrialEquipment中规定的所有动作的情形</p>
<img src="/2022/05/18/software/image-20220520112557588.png" class="" title="image-20220520112557588">

<h3 id="5-5UML的图"><a href="#5-5UML的图" class="headerlink" title="5.5UML的图"></a>5.5UML的图</h3><p>这位更是重量级，分两大类：结构图、行为图</p>
<img src="/2022/05/18/software/image-20220520112721540.png" class="" title="image-20220520112721540">

<h4 id="1-用例图"><a href="#1-用例图" class="headerlink" title="1.用例图"></a>1.用例图</h4><p>用例模型描述的是参与者(actor)所理解的系统功能。用例模型用于需求分析阶段，它的建立是系统开发者和用户反复讨论的结果，描述了开发者和用户对需求规格达成的共识。在UML中，一个用例模型由若干个用例图来描述，用例图的主要元素是用例和执行者。用例图是包括执行者、由系统边界（一个矩形）封闭的一组用例，执行者和用例之间的关联、用例间关系以及执行者的泛化的图。</p>
<img src="/2022/05/18/software/image-20220520151908896.png" class="" title="image-20220520151908896">

<p> 用例之间可以有泛化、扩展、使用（包含）三种关系。</p>
<ol>
<li>泛化关系：用例泛化是指一个用例可以被特别列举为一个或多个子用例。</li>
<li>扩展关系：向一个用例中加入一些新的动作后构成了另一个用例，这两个用例之间的关系就是扩展关系，后者通过继承前者的一些行为得来，通常把后者称为扩展用例。</li>
<li>使用（包含）关系：当一个用例使用另一个用例时，这两个用例之间就构成了使用关系。当有一大块相似的动作存在于几个用例，又不想重复描述该动作，将重复的部分分离为一个用例，两用例间关系称为使用关系。</li>
</ol>
<img src="/2022/05/18/software/image-20220520153201507.png" class="" title="image-20220520153201507">

<h4 id="2-类图"><a href="#2-类图" class="headerlink" title="2.类图"></a>2.类图</h4><p>类图描述类和类与类之间的静态关系，它是从静态角度表示系统的，因此类图属于一种静态模型。类图是构建其他图的基础，没有类图就没有状态图、协作图等其他图，也就无法表示系统其他方面的特性。   </p>
<p>类图显示了类（及其接口）、类的内部结构以及与其他类的联系。联系是指类元之间的联系，在类的建模中可以使用<strong>关联、聚合和泛化</strong>（继承）关系。</p>
<img src="/2022/05/18/software/image-20220520154357262.png" class="" title="image-20220520154357262">

<img src="/2022/05/18/software/image-20220520154402767.png" class="" title="image-20220520154402767">

<p>关联类是指表示其他类之间关联关系的类。当一个关联具有自己的属性并需要存储它们时，就需要用关联类建模。关联类用虚线连接在两个类之间的联系上。</p>
<img src="/2022/05/18/software/image-20220520154416726.png" class="" title="image-20220520154416726">



<h4 id="3-顺序图和通信图"><a href="#3-顺序图和通信图" class="headerlink" title="3.顺序图和通信图"></a>3.顺序图和通信图</h4><img src="/2022/05/18/software/image-20220520160324655.png" class="" title="image-20220520160324655">

<p>•通信图是顺序图的一种变化形式，用于描述相互协作的对象间的交互关系和链接关系。</p>
<img src="/2022/05/18/software/image-20220520160338774.png" class="" title="image-20220520160338774">





<h4 id="4-状态图"><a href="#4-状态图" class="headerlink" title="4.状态图"></a>4.状态图</h4><p>状态图描述一个特定对象的所有可能的状态以及引起状态转换的事件。大多数面向对象技术都用状态图表示单个对象在其生命期中的行为。一个状态图包括一系列状态、事件以及状态之间的转移。</p>
<p>•所有对象都具有状态，状态是对象执行了一系列活动的结果。当某个事件发生后，对象的状态将发生变化。在状态图中定义的状态可能有：初态(初始状态)、终态(最终状态)、中间状态和复合状态。</p>
<p>•在一张状态图中只能有<strong>一个初态</strong>，而<strong>终态则可以有多个</strong>。</p>
<img src="/2022/05/18/software/image-20220520160444022.png" class="" title="image-20220520160444022">

<p>中间状态用圆角矩形表示，可能包含三个部分，第一部分为状态的名称；第二部分为状态变量的名字和值，这部分是可选的；第三部分是活动表，这部分也是可选的。</p>
<img src="/2022/05/18/software/image-20220520160526541.png" class="" title="image-20220520160526541">中间状态

<img src="/2022/05/18/software/image-20220520160633030.png" class="" title="image-20220520160633030">电梯的状态图(状态图没有终点)

<img src="/2022/05/18/software/image-20220520160728415.png" class="" title="image-20220520160728415">带有事件说明的状态转换





<h4 id="5-活动图"><a href="#5-活动图" class="headerlink" title="5.活动图"></a>5.活动图</h4><p>Ø活动图用来捕捉用例的活动，使用框图的方式显示动作及其结果。</p>
<p>Ø活动图是一个流图，描述了从活动到活动的流。</p>
<p>Ø它是另一种描述交互的方式，它描述采取何种动作，动作的结果是什么(动作状态改变)，何时发生(动作序列)，以及在何处发生(泳道)。 </p>
<img src="/2022/05/18/software/image-20220520161228352.png" class="" title="image-20220520161228352">





<h4 id="6-构件图和部署图"><a href="#6-构件图和部署图" class="headerlink" title="6.构件图和部署图"></a>6.构件图和部署图</h4><p>Ø构件图描述软件构件及构件之间的依赖关系，显示代码的静态结构。</p>
<p>Ø构件是逻辑架构中定义的概念和功能(例如，类、对象及它们之间的关系)在物理架构中的实现。典型情况下，构件是开发环境中的实现文件。</p>
<p>软件构件可以是下述的任何一种构件。</p>
<p>•源构件：源构件仅在编译时才有意义。典型情况下，它是实现一个或多个类的源代码文件。</p>
<p>•二进制构件：典型情况下，二进制构件是对象代码，它是源构件的编译结果。</p>
<p>•可执行构件：可执行构件是一个可执行的程序文件，它是链接所有二进制构件所得到的结果。一个可执行构件代表在处理器(计算机)上运行的可执行单元。</p>
<img src="/2022/05/18/software/image-20220520161421245.png" class="" title="image-20220520161421245">画图系统的构件图

<img src="/2022/05/18/software/image-20220520161432807.png" class="" title="image-20220520161432807">银行储蓄系统的构件图

<p>•部署图描述处理器、设备和连接，它显示系统硬件的物理拓扑结构及在此结构上执行的软件。</p>
<p>•部署图可以显示计算节点的拓扑结构和通信路径、节点上运行的软件以及软件包含的逻辑单元。</p>
<img src="/2022/05/18/software/image-20220520161453359.png" class="" title="image-20220520161453359">



<h4 id="？"><a href="#？" class="headerlink" title="？"></a>？</h4><p>•UML中有两种类型的交互图：顺序图和协作图。</p>
<p>•顺序图描述对象之间的动态交互关系，着重表现对象间消息传递的时间顺序。顺序图中的符号如下:  </p>
<img src="/2022/05/18/software/image-20220520160236079.png" class="" title="image-20220520160236079">

<p>UML定义的三种消息：</p>
<p>•<strong>简单消息</strong>：表示简单的控制流，它只是表示控制从一个对象传给另一个对象，而没有描述通信的任何细节。</p>
<p>•<strong>同步消息</strong>：表示嵌套的控制流，操作的调用是一种典型的同步消息。调用者发出消息后必须等待消息返回，只有当处理消息的操作执行完毕后，调用者才可以继续执行自己的操作。</p>
<p><strong>异步消息</strong>：表示异步控制流，发送者发出消息后不用等待消息处理完就可以继续执行自己的操作。异步消息主要用于描述实时系统中的并发行为</p>
<img src="/2022/05/18/software/image-20220520160250925.png" class="" title="image-20220520160250925">





<h3 id="5-6使用和扩展UML"><a href="#5-6使用和扩展UML" class="headerlink" title="5.6使用和扩展UML"></a>5.6使用和扩展UML</h3><p>使用UML的准则</p>
<p>不要试图使用所有的图形和符号</p>
<p>应该根据项目的特点，选用最适用的图形和符号。一般来说，应该优先选用简单的图形和符号，例如，用例、类、关联、属性和继承等概念是最常用的。</p>
<p>不要为每个事物都画一个模型</p>
<p>应该把精力集中于关键的领域。最好只画几张关键的图，经常使用并不断更新、修改这几张图。</p>
<p>应该分层次地画模型图</p>
<p>根据项目进展的不同阶段，用正确的观点画模型图。如果处于分析阶段，应该画概念层模型图；当开始着手进行软件设计时，应该画设计层模型图；当考察某个特定的实现方案时，则应画实现层模型图。</p>
<p>使用UML的最大危险是过早地陷入实现细节。为了避免这一危险，应该把重点放在概念层和说明层。 </p>
<p>模型应该具有协调性</p>
<p>模型必须在每个抽象层次内和不同的抽象层次之间协调</p>
<p>模型和模型元素的大小应该适中</p>
<p>过于复杂的模型和模型元素难于理解也难于使用，这样的模型和模型元素很难生存下去。如果要建模的问题相当复杂，则可以把该问题分解成若干个子问题，分别为每个子问题建模，每个子模型构成原模型中的一个包，以降低建模的难度和模型的复杂性。**</p>
<p>扩展UML的机制</p>
<p>•为避免使UML变得过于复杂，UML并没有吸收所有面向对象的建模技术和机制，而是设计了适当的扩展机制，使得它能很容易地适应某些特定的方法、机构或用户的需要。利用扩展机制，用户可以定义和使用自己的模型元素。</p>
<p>•扩展的基础是UML的模型元素，利用扩展机制可以给这些元素的变形加上新的语义。新语义可以有三种形式：重新定义，增加新语义或者对某种元素的使用增加一些限制。相应地，有下述三种扩展机制。</p>
<p><strong>构造型</strong> <strong>(stereotype)</strong></p>
<p>构造型是在一个已定义的模型元素的基础上构造的一种新的模型元素。构造型的信息内容和形式与已存在的基本模型元素相同，但是含义和使用不同。 </p>
<p><strong>标记值</strong> <strong>(tagged value)</strong></p>
<p>标记值可以用来存储元素的任意信息，对于存储项目管理信息尤其有用的，如元素的创建日期、开发状态、截止日期和测试状态。</p>
<p>标记值用字符串表示，字符串有标记名、等号和值。它们被规则地放置在大括弧内。 </p>
<p><strong>约束</strong> <strong>(constraint)</strong></p>
<p>约束是用文字表达式表示的语义限制。约束用大括弧内的字符串表达式表示。约束可以附加在表元素、依赖关系，或注释上。 </p>
<h2 id="6-面向对象分析"><a href="#6-面向对象分析" class="headerlink" title="6.面向对象分析"></a>6.面向对象分析</h2><h3 id="6-1面向对象分析概述"><a href="#6-1面向对象分析概述" class="headerlink" title="6.1面向对象分析概述"></a>6.1面向对象分析概述</h3><p>面向对象分析就是抽取和整理用户需求并建立问题域精确模型的过程。</p>
<h4 id="1-确定系统边界"><a href="#1-确定系统边界" class="headerlink" title="1.确定系统边界"></a>1.确定系统边界</h4><p>Ø系统边界是系统的所有内部成分与系统以外各种事物的分界线。系统只通过边界上有限数量的接口与外部的系统参与者（人员、组织、设备或外系统）进行交互。</p>
<img src="/2022/05/18/software/image-20220520213124618.png" class="" title="image-20220520213124618">

<h4 id="2-三种模型"><a href="#2-三种模型" class="headerlink" title="2.三种模型"></a>2.三种模型</h4><p>Ø用例模型：用例和场景表示的功能模型；</p>
<p>Ø对象模型：用类和对象表示的静态模型；</p>
<p>Ø交互模型：由状态图和顺序图表示的动态模型。</p>
<p>用例模型从用户角度描述系统功能，是整个后续工作的基础，也是测试与验收的依据 ；对象模型是核心模型，解决任何问题，几乎都需要从客观世界实体及实体间相互联系中抽象出极有价值的对象模型；当问题涉及交互作用和时序时，交互模型是重要的。</p>
<h3 id="6-2建立用例模型"><a href="#6-2建立用例模型" class="headerlink" title="6.2建立用例模型"></a>6.2建立用例模型</h3><p>建立用例模型的过程</p>
<ol>
<li><p>确定业务参与者──标识目标系统将支持的不同类型的用户，可以是人、事件或其他系统。</p>
<p>通过关注系统的业务参与者，我们可以将重点放在如何使用系统，而不是如何构造系统上，并且有助于进一步明确系统的范围和边界。</p>
<p>当系统比较庞大和复杂时，要搞清楚系统的需求往往比较困难，通过明确参与者，可以针对参与者确定系统需求，有助于保证系统需求的完整性</p>
<p>从以下三个方面识别参与者：</p>
<p> 人员或组织：直接使用系统的人员或组织</p>
<p> 外部系统：所有与本系统交互的外部系统</p>
<p> 设备：所有与系统交互的设备</p>
<p>可通过以下资料来确定系统的参与者：</p>
<p>标识系统范围和边界的环境图；</p>
<p>现有系统（如果有的话）的文档和用户手册；</p>
<p>项目会议和研讨会的记录；</p>
<p>现有的需求文档、工作手册等。</p>
<img src="/2022/05/18/software/image-20220520213602061.png" class="" title="image-20220520213602061">

<p>•环境图是分析参与者和发现潜在用例的极好来源，它不仅可以用在结构化分析方法中，也可以用于面向对象的分析方法中。</p>
<p>•通过环境图，可以确定系统的主要输入输出，通过提交和接收输入输出的各方确定潜在的用例。</p>
<p>•对用例的完整描述包括用例名称、执行者、前置条件、后置条件、一个主事件流、零到多个备选事件流。</p>
<p>•主事件流表示正常情况下执行者与系统之间的信息交互及动作序列，备选事件流则表示特殊情况或异常情况下的信息交互及动作序列。</p>
<p>•应给出每个用例的规格说明。</p>
<p>•用例图是若干个参与者和用例，以及它们间的关系构成的图形表示。</p>
<p>•每个系统通常都有一个总体视图（Global View of Actors and Use Cases），如果总体视图过于复杂，则可以创建多个用例图，每个用例图关注系统的某一方面。</p>
<p>•通常是围绕参与者创建用例图。 </p>
</li>
<li><p>确定业务需求用例──参与者需要系统提供的完整功能。</p>
</li>
<li><p>创建用例图──标识参与者与用例之间、用例与用例之间的关系。</p>
</li>
</ol>
<h3 id="6-3建立对象模型"><a href="#6-3建立对象模型" class="headerlink" title="6.3建立对象模型"></a>6.3建立对象模型</h3><h3 id="6-4建立动态模型"><a href="#6-4建立动态模型" class="headerlink" title="6.4建立动态模型"></a>6.4建立动态模型</h3><p>顺序图</p>
<p>通信图</p>
<p>状态图</p>
<h1 id="Part4-软件实现与测试"><a href="#Part4-软件实现与测试" class="headerlink" title="Part4.软件实现与测试"></a>Part4.软件实现与测试</h1><h1 id="Part5-软件维护与软件管理"><a href="#Part5-软件维护与软件管理" class="headerlink" title="Part5.软件维护与软件管理"></a>Part5.软件维护与软件管理</h1>
      </section>

      
      
        <nav class="article-nav">
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
    <div class="card-text">
      
        <a href="/2022/05/19/deepTest/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">机器学习-恒星星系分类</h2>
        </a>
      
      <div class="card-text--row">Newer</div>
    </div>
  </article>
</div>
          
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
    <div class="card-text">
      
        <a href="/2022/05/13/DataStructuresTest/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">数据结构题集整理</h2>
        </a>
      
      <div class="card-text--row">Older</div>
    </div>
  </article>
</div>
          
        </nav>
      

      <section class="page-message-container layout-padding">
        


  
  

  
  


      </section>
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="/img/avator.png" class="soft-size--round soft-style--box" alt="STERNE">
    
    
      <h2>STERNE</h2>
    
    
      <p>SDUer，大一入门，大二入土...</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>52</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        1
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        20
      </div>
    </div>
  </div>
</section>

      
<section class="widget-toc widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-toc" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M134.50666666 767.46666668H460.8c27.73333333 0 50.24000001 22.50666668 50.24000001 50.23999999v50.13333333c0 27.73333333-22.50666668 50.24000001-50.24000001 50.24000001H134.50666666c-27.73333333 0-50.24000001-22.50666668-50.23999999-50.24000001v-50.13333333c0.10666668-27.73333333 22.50666668-50.24000001 50.24000001-50.24000001zM84.37333332 541.65333333h326.18666669c27.73333333 0 50.24000001 22.39999999 50.23999999 50.13333334v50.24000001c0 27.73333333-22.50666668 50.24000001-50.24000002 50.23999999H84.37333332c-27.73333333 0-50.24000001-22.50666668-50.23999999-50.23999999v-50.24000001c0-27.73333333 22.50666668-50.13333334 50.24000001-50.13333334zM134.50666666 315.83999999H460.8c27.73333333 0 50.24000001 22.50666668 50.24000001 50.24000001v50.24000001c0 27.73333333-22.50666668 50.13333334-50.24000001 50.13333333H134.50666666c-27.73333333 0-50.24000001-22.39999999-50.23999999-50.13333333v-50.24000001c0.10666668-27.84000001 22.50666668-50.24000001 50.24000001-50.23999999zM209.81333332 89.91999999h326.18666671c27.73333333 0 50.24000001 22.39999999 50.23999997 50.13333335v50.23999999c0 27.73333333-22.50666668 50.24000001-50.24000001 50.24000001H209.81333332c-27.73333333 0-50.24000001-22.50666668-50.23999999-50.24000001v-50.24000001c0-27.73333333 22.50666668-50.13333334 50.24000001-50.13333333zM692.05333333 623.36l274.66666669 176.00000002c23.36000001 14.93333333 30.08 45.97333334 15.14666666 69.33333332L954.77333334 910.93333333c-14.93333333 23.25333334-45.97333334 30.08-69.33333335 15.14666667l-274.66666666-176c-23.36000001-14.93333333-30.08-45.97333334-15.14666667-69.33333333l27.09333334-42.24000001c14.93333333-23.36000001 46.08000001-30.08 69.33333333-15.14666666z" fill="currentColor"></path>
</svg>
    <span>TOC</span>
  </div>
  <div class="widget-body">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Part1.软件工程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.软件与软件工程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1软件的概念、特性和分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">软件质量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2软件危机与软件工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3软件工程的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4软件生存期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">软件定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">软件开发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">概要设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">详细设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81%E5%92%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">程序编码和单元测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.4.2.4.</span> <span class="toc-text">集成测试和系统测试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%B4%E6%8A%A4"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">运行维护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5软件工程方法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%9A%E6%96%B9%E6%B3%95%E3%80%81%E5%B7%A5%E5%85%B7%E5%92%8C%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">三要素：方法、工具和过程。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6软件工具概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%8F%8A%E7%9F%A5%E8%AF%86%E5%9F%9F"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.7软件工程知识体系及知识域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2.软件生存期模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1瀑布模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2快速原型模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3增量模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.2.3.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4螺旋模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">完整的螺旋模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B%E7%9A%844%E9%A1%B9%E6%B4%BB%E5%8A%A8"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">螺旋模型的4项活动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5喷泉模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6统一过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">工作流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">阶段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E5%9F%BA%E4%BA%8E%E6%9E%84%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7基于构件的开发模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8%E6%95%8F%E6%8D%B7%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.8.</span> <span class="toc-text">2.8敏捷过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">使用范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B%EF%BC%88eXtreme-Programming%EF%BC%8CXP%EF%BC%89"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">极限编程（eXtreme Programming，XP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">自适应软件开发</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part2-%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">Part2.结构化分析与设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">3.软件需求获取与结构化分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E4%B8%8E%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.1.1.</span> <span class="toc-text">3.1需求获取与需求分析阶段的任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1.需求获取的任务和原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">2.需求获取的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E9%AB%98%E5%B1%82%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.1.2.1.</span> <span class="toc-text">开发高层的业务模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%A1%B9%E7%9B%AE%E8%8C%83%E5%9B%B4%E5%92%8C%E9%AB%98%E5%B1%82%E9%9C%80%E6%B1%82"><span class="toc-number">2.1.1.2.2.</span> <span class="toc-text">定义项目范围和高层需求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E7%94%A8%E6%88%B7%E7%B1%BB%E5%92%8C%E7%94%A8%E6%88%B7%E4%BB%A3%E8%A1%A8"><span class="toc-number">2.1.1.2.3.</span> <span class="toc-text">识别用户类和用户代表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B7%E4%BD%93%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-number">2.1.1.2.4.</span> <span class="toc-text">获取具体的需求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%9B%AE%E6%A0%87%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">2.1.1.2.5.</span> <span class="toc-text">确定目标系统的业务工作流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E6%95%B4%E7%90%86%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.1.2.6.</span> <span class="toc-text">需求整理与总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">3.软件需求分析阶段的任务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96"><span class="toc-number">2.1.1.3.1.</span> <span class="toc-text">需求获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">2.1.1.3.2.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.3.3.</span> <span class="toc-text">需求定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E9%AA%8C%E8%AF%81"><span class="toc-number">2.1.1.3.4.</span> <span class="toc-text">需求验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">3.2结构化分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%9F%E8%83%BD%E5%BB%BA%E6%A8%A1%EF%BC%88%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%EF%BC%89"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">1.功能建模（数据流图）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.1.2.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%9B%BE"><span class="toc-number">2.1.2.1.2.</span> <span class="toc-text">环境图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E7%9A%84%E5%88%86%E5%B1%82"><span class="toc-number">2.1.2.1.3.</span> <span class="toc-text">数据流图的分层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">2.1.2.1.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%EF%BC%88ER%E5%9B%BE%EF%BC%89"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">2.数据建模（ER图）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.2.2.1.</span> <span class="toc-text">数据对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.2.2.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.2.2.3.</span> <span class="toc-text">关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.2.2.4.</span> <span class="toc-text">关系的属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%EF%BC%88%E7%8A%B6%E6%80%81%E5%9B%BE%EF%BC%89"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">3.行为建模（状态图）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.2.3.1.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.2.3.2.</span> <span class="toc-text">状态的表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.2.3.3.</span> <span class="toc-text">状态转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.1.2.3.4.</span> <span class="toc-text">事件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">4.数据字典</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%8D%E6%9D%A1%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.1.2.4.1.</span> <span class="toc-text">词条描述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AF%8D%E6%9D%A1"><span class="toc-number">2.1.2.4.1.1.</span> <span class="toc-text">数据流词条</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E8%AF%8D%E6%9D%A1"><span class="toc-number">2.1.2.4.1.2.</span> <span class="toc-text">数据元素词条</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E8%AF%8D%E6%9D%A1"><span class="toc-number">2.1.2.4.1.3.</span> <span class="toc-text">数据存储文件词条</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A0%E5%B7%A5%E8%AF%8D%E6%9D%A1"><span class="toc-number">2.1.2.4.1.4.</span> <span class="toc-text">加工词条</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E7%82%B9%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%B1%87%E7%82%B9%E8%AF%8D%E6%9D%A1"><span class="toc-number">2.1.2.4.1.5.</span> <span class="toc-text">数据源点及数据汇点词条</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.1.2.4.2.</span> <span class="toc-text">数据结构描述</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8A%A0%E5%B7%A5%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">5.加工规格说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E8%A1%A8"><span class="toc-number">2.1.2.5.1.</span> <span class="toc-text">决策表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E6%A0%91"><span class="toc-number">2.1.2.5.2.</span> <span class="toc-text">决策树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.3系统需求规格说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E9%9C%80%E6%B1%82%E8%AF%84%E5%AE%A1"><span class="toc-number">2.1.4.</span> <span class="toc-text">3.4需求评审</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E9%9C%80%E6%B1%82%E7%AE%A1%E7%90%86"><span class="toc-number">2.1.5.</span> <span class="toc-text">3.5需求管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">4.结构化设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8E%9F%E5%88%99"><span class="toc-number">2.2.1.</span> <span class="toc-text">4.1软件设计的概念及原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%88%99-1"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="toc-number">2.2.1.2.1.</span> <span class="toc-text">(1) 分而治之</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A8%A1%E5%9D%97%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">2.2.1.2.2.</span> <span class="toc-text">(2) 模块独立性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%80%A6%E5%90%88"><span class="toc-number">2.2.1.2.2.1.</span> <span class="toc-text">耦合</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E7%9B%B4%E6%8E%A5%E8%80%A6%E5%90%88-Nondirect-Coupling"><span class="toc-number">2.2.1.2.2.2.</span> <span class="toc-text">非直接耦合(Nondirect Coupling)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%80%A6%E5%90%88-Data-Coupling"><span class="toc-number">2.2.1.2.2.3.</span> <span class="toc-text">数据耦合 (Data Coupling)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E8%80%A6%E5%90%88-Stamp-Coupling"><span class="toc-number">2.2.1.2.2.4.</span> <span class="toc-text">特征耦合 (Stamp Coupling)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%80%A6%E5%90%88-Control-Coupling"><span class="toc-number">2.2.1.2.2.5.</span> <span class="toc-text">控制耦合 (Control Coupling)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E8%80%A6%E5%90%88%EF%BC%88Common-Coupling%EF%BC%89"><span class="toc-number">2.2.1.2.2.6.</span> <span class="toc-text">公共耦合（Common Coupling）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E8%80%A6%E5%90%88-Content-Coupling"><span class="toc-number">2.2.1.2.2.7.</span> <span class="toc-text">内容耦合 (Content Coupling)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E8%81%9A"><span class="toc-number">2.2.1.2.2.8.</span> <span class="toc-text">内聚</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%81%B6%E7%84%B6%E5%86%85%E8%81%9A%EF%BC%88Coincidental-Cohesion%EF%BC%89"><span class="toc-number">2.2.1.2.2.9.</span> <span class="toc-text">偶然内聚（Coincidental Cohesion）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%86%85%E8%81%9A%EF%BC%88Logical-Cohesion%EF%BC%89"><span class="toc-number">2.2.1.2.2.10.</span> <span class="toc-text">逻辑内聚（Logical Cohesion）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%86%85%E8%81%9A%EF%BC%88Classical-Cohesion%EF%BC%89"><span class="toc-number">2.2.1.2.2.11.</span> <span class="toc-text">时间内聚（Classical Cohesion）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%86%85%E8%81%9A%EF%BC%88Procedural-Cohesion%EF%BC%89"><span class="toc-number">2.2.1.2.2.12.</span> <span class="toc-text">过程内聚（Procedural Cohesion）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%86%85%E8%81%9A%EF%BC%88Communicational-Cohesion-%E4%BA%A6%E7%A7%B0%E6%95%B0%E6%8D%AE%E5%86%85%E8%81%9A"><span class="toc-number">2.2.1.2.2.13.</span> <span class="toc-text">通信内聚（Communicational Cohesion) 亦称数据内聚</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%86%85%E8%81%9A"><span class="toc-number">2.2.1.2.2.14.</span> <span class="toc-text">顺序内聚</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%86%85%E8%81%9A-Functional-Cohesion"><span class="toc-number">2.2.1.2.2.15.</span> <span class="toc-text">功能内聚 (Functional Cohesion)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8F%90%E9%AB%98%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1"><span class="toc-number">2.2.1.2.3.</span> <span class="toc-text">(3) 提高抽象层次</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%A4%8D%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.1.2.4.</span> <span class="toc-text">(4) 复用性设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%81%B5%E6%B4%BB%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.1.2.5.</span> <span class="toc-text">(5) 灵活性设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.2.</span> <span class="toc-text">4.2结构化设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">结构化软件设计的任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">结构化设计与结构化分析的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E5%8F%8A%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">模块结构及表示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">2.2.2.3.1.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.2.3.2.</span> <span class="toc-text">模块分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.2.3.3.</span> <span class="toc-text">模块的结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">2.2.2.3.4.</span> <span class="toc-text">结构图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">数据结构及表示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.3.</span> <span class="toc-text">4.3体系结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">基于数据流方法的设计过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">典型的数据流类型和系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%98%E6%8D%A2%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">2.2.3.2.1.</span> <span class="toc-text">变换型数据流和变换型系统结构图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E4%BA%8B%E5%8A%A1%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">2.2.3.2.2.</span> <span class="toc-text">事务型数据流和事务型系统结构图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E5%9E%8B%E6%98%A0%E5%B0%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">变换型映射方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9E%8B%E6%98%A0%E5%B0%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">事务型映射方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E7%9A%84%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.5.</span> <span class="toc-text">软件模块结构的改进方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%8C%E5%96%84%E5%8C%96%E3%80%82"><span class="toc-number">2.2.3.5.1.</span> <span class="toc-text">(1)模块功能的完善化。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%94%B9%E5%96%84%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%82"><span class="toc-number">2.2.3.5.2.</span> <span class="toc-text">(2) 消除重复功能，改善软件结构。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E5%BA%94%E5%9C%A8%E6%8E%A7%E5%88%B6%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%86%85%E3%80%82"><span class="toc-number">2.2.3.5.3.</span> <span class="toc-text">(3) 模块的作用范围应在控制范围之内。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%87%8F%E5%B0%91%E9%AB%98%E6%89%87%E5%87%BA%E7%BB%93%E6%9E%84%EF%BC%8C%E9%9A%8F%E7%9D%80%E6%B7%B1%E5%BA%A6%E5%A2%9E%E5%A4%A7%E6%89%87%E5%85%A5%E3%80%82"><span class="toc-number">2.2.3.5.4.</span> <span class="toc-text">(4) 尽可能减少高扇出结构，随着深度增大扇入。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E9%81%BF%E5%85%8D%E6%88%96%E5%87%8F%E5%B0%91%E4%BD%BF%E7%94%A8%E7%97%85%E6%80%81%E8%BF%9E%E6%8E%A5%E3%80%82"><span class="toc-number">2.2.3.5.5.</span> <span class="toc-text">(5) 避免或减少使用病态连接。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%A6%81%E9%80%82%E4%B8%AD%E3%80%82"><span class="toc-number">2.2.3.5.6.</span> <span class="toc-text">(6) 模块的大小要适中。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B-%E9%93%B6%E8%A1%8C%E5%82%A8%E8%93%84%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.2.3.5.7.</span> <span class="toc-text">例 银行储蓄系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.4.</span> <span class="toc-text">4.4接口设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">接口设计概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">人机交互界面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%BA%94%E5%85%B7%E5%A4%87%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.2.4.2.1.</span> <span class="toc-text">用户界面应具备的特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.4.2.2.</span> <span class="toc-text">用户类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.4.2.3.</span> <span class="toc-text">界面设计类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">2.2.4.2.4.</span> <span class="toc-text">设计详细的交互</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E6%95%B0%E6%8D%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.5.</span> <span class="toc-text">4.5数据设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">文件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">数据库设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">2.2.5.2.1.</span> <span class="toc-text">数据对象实体的映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">2.2.5.2.2.</span> <span class="toc-text">关系的映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6%E8%BF%87%E7%A8%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.6.</span> <span class="toc-text">4.6过程设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">结构化程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">程序流程图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N-S%E5%9B%BE"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">N-S图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PAD%E5%9B%BE"><span class="toc-number">2.2.6.4.</span> <span class="toc-text">PAD图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.6.5.</span> <span class="toc-text">伪代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E3%80%81%E9%80%90%E6%AD%A5%E7%BB%86%E5%8C%96%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.6.6.</span> <span class="toc-text">自顶向下、逐步细化的设计过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E"><span class="toc-number">2.2.7.</span> <span class="toc-text">4.7软件设计规格说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1"><span class="toc-number">2.2.8.</span> <span class="toc-text">4.8软件设计评审</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">Part3.面向对象分析与设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8EUML"><span class="toc-number">3.1.</span> <span class="toc-text">5.面向对象方法与UML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">5.1面向对象的概念与开发方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">1.对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">2.类与封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%A7%E6%89%BF"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">3.继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%9A%E6%80%81"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">4.多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">5.消息通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.6.</span> <span class="toc-text">6.面向对象软件开发方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Booch%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.6.1.</span> <span class="toc-text">Booch方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Rumbaugh%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.6.2.</span> <span class="toc-text">Rumbaugh方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Coad%E5%92%8CYourdon%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.6.3.</span> <span class="toc-text">Coad和Yourdon方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Jacobson%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.6.4.</span> <span class="toc-text">Jacobson方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2UML%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">5.2UML简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-UML%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">1.UML特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-UML%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">2.UML基本模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3UML%E4%BA%8B%E7%89%A9"><span class="toc-number">3.1.3.</span> <span class="toc-text">5.3UML事物</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84%E4%BA%8B%E7%89%A9"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">1.结构事物</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A1%8C%E4%B8%BA%E4%BA%8B%E7%89%A9"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">2.行为事物</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%86%E7%BB%84%E4%BA%8B%E7%89%A9"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">3.分组事物</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B3%A8%E9%87%8A%E4%BA%8B%E7%89%A9"><span class="toc-number">3.1.3.4.</span> <span class="toc-text">4.注释事物</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4UML%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.4.</span> <span class="toc-text">5.4UML关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">1.依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">2.关联关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%85%B3%E8%81%94"><span class="toc-number">3.1.4.2.1.</span> <span class="toc-text">普通关联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E5%85%B3%E8%81%94"><span class="toc-number">3.1.4.2.2.</span> <span class="toc-text">多元关联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E5%AE%9A%E5%85%B3%E8%81%94"><span class="toc-number">3.1.4.2.3.</span> <span class="toc-text">限定关联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB"><span class="toc-number">3.1.4.2.4.</span> <span class="toc-text">关联类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">3.1.4.2.5.</span> <span class="toc-text">聚合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA"><span class="toc-number">3.1.4.2.6.</span> <span class="toc-text">导航</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">3.泛化关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%B3%9B%E5%8C%96"><span class="toc-number">3.1.4.3.1.</span> <span class="toc-text">普通泛化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%97%E9%99%90%E6%B3%9B%E5%8C%96"><span class="toc-number">3.1.4.3.2.</span> <span class="toc-text">受限泛化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.4.4.</span> <span class="toc-text">4.实现关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5UML%E7%9A%84%E5%9B%BE"><span class="toc-number">3.1.5.</span> <span class="toc-text">5.5UML的图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E4%BE%8B%E5%9B%BE"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">1.用例图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E5%9B%BE"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">2.类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A1%BA%E5%BA%8F%E5%9B%BE%E5%92%8C%E9%80%9A%E4%BF%A1%E5%9B%BE"><span class="toc-number">3.1.5.3.</span> <span class="toc-text">3.顺序图和通信图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="toc-number">3.1.5.4.</span> <span class="toc-text">4.状态图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B4%BB%E5%8A%A8%E5%9B%BE"><span class="toc-number">3.1.5.5.</span> <span class="toc-text">5.活动图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%9E%84%E4%BB%B6%E5%9B%BE%E5%92%8C%E9%83%A8%E7%BD%B2%E5%9B%BE"><span class="toc-number">3.1.5.6.</span> <span class="toc-text">6.构件图和部署图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%9F"><span class="toc-number">3.1.5.7.</span> <span class="toc-text">？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6%E4%BD%BF%E7%94%A8%E5%92%8C%E6%89%A9%E5%B1%95UML"><span class="toc-number">3.1.6.</span> <span class="toc-text">5.6使用和扩展UML</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">6.面向对象分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">6.1面向对象分析概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A1%AE%E5%AE%9A%E7%B3%BB%E7%BB%9F%E8%BE%B9%E7%95%8C"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">1.确定系统边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">2.三种模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E5%BB%BA%E7%AB%8B%E7%94%A8%E4%BE%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">6.2建立用例模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.3.</span> <span class="toc-text">6.3建立对象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E5%BB%BA%E7%AB%8B%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.4.</span> <span class="toc-text">6.4建立动态模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part4-%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text">Part4.软件实现与测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part5-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E4%B8%8E%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">Part5.软件维护与软件管理</span></a></li></ol>
  </div>
</section>


      
<section class="widet-notice widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-notice" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M512 945.02305225v28.15620663a24.27259221 24.27259221 0 0 1-24.27259221 24.27259335H394.0352a48.54518557 48.54518557 0 0 1-41.74885888-23.78714112l-110.68302222-184.47170332a132.04290333 132.04290333 0 0 1-17.47626667-48.54518557h118.4502511a200.97706667 200.97706667 0 0 1 76.21594113 14.56355556l20.38897777 133.49925888a48.54518557 48.54518557 0 0 0 36.40888888 27.67075555l16.01991111 2.91271112a24.27259221 24.27259221 0 0 1 20.38897778 25.72894889zM997.45185223 463.45481443a194.18074112 194.18074112 0 0 1-38.8361489 116.50844445 24.75804445 24.75804445 0 0 1-36.4088889 0l-34.95253333-34.95253333a24.27259221 24.27259221 0 0 1-2.91271111-30.58346667 97.09036999 97.09036999 0 0 0 0-106.79940665 24.27259221 24.27259221 0 0 1 2.91271111-30.58346666l34.95253333-34.95253334a24.75804445 24.75804445 0 0 1 18.93262223-7.28177777 26.2144 26.2144 0 0 1 17.47626667 9.70903665A194.18074112 194.18074112 0 0 1 997.45185223 463.45481443z m-194.18074112-388.36148111v776.72296335a48.54518557 48.54518557 0 0 1-48.54518556 48.54518443h-28.64165888a48.54518557 48.54518557 0 0 1-33.98163001-14.07810332l-145.63555556-143.20829668A291.27111111 291.27111111 0 0 0 342.57730333 657.63555556H172.18370333a145.63555556 145.63555556 0 0 1-145.63555556-145.63555556v-97.09036999a145.63555556 145.63555556 0 0 1 145.63555556-145.63555556h170.3936a291.27111111 291.27111111 0 0 0 206.31703779-85.43952668l145.63555555-143.20829554a48.54518557 48.54518557 0 0 1 33.98162888-14.07810446H754.72592555a48.54518557 48.54518557 0 0 1 48.54518556 48.54518555z" fill="currentColor"></path>
</svg>
    <span>NOTICE</span>
  </div>
  <div class="widget-body">
    <p>这里还什么都没有呢喵~</p>
  </div>
</section>


      <section class="widget-categorys widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
    <span>CATEGORYS</span>
  </div>
  <div class="widget-body">
    <ul class="categorys-list">
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/">
            帮助文档 (5)
          </a>
        </li>
      
    </ul>
  </div>
</section>

      <section class="widget-tags widget-item  layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/tags/ACM/" style="font-size: 15px;" class="tags-cloud-5">ACM</a> <a href="/tags/Arc/" style="font-size: 11px;" class="tags-cloud-1">Arc</a> <a href="/tags/CCPC/" style="font-size: 14px;" class="tags-cloud-4">CCPC</a> <a href="/tags/HPC/" style="font-size: 10px;" class="tags-cloud-0">HPC</a> <a href="/tags/bot/" style="font-size: 10px;" class="tags-cloud-0">bot</a> <a href="/tags/c/" style="font-size: 13px;" class="tags-cloud-3">c</a> <a href="/tags/cpp/" style="font-size: 20px;" class="tags-cloud-10">cpp</a> <a href="/tags/deeplearning/" style="font-size: 17px;" class="tags-cloud-7">deeplearning</a> <a href="/tags/games/" style="font-size: 12px;" class="tags-cloud-2">games</a> <a href="/tags/hexo/" style="font-size: 11px;" class="tags-cloud-1">hexo</a> <a href="/tags/java/" style="font-size: 10px;" class="tags-cloud-0">java</a> <a href="/tags/maths/" style="font-size: 10px;" class="tags-cloud-0">maths</a> <a href="/tags/note/" style="font-size: 11px;" class="tags-cloud-1">note</a> <a href="/tags/python/" style="font-size: 18px;" class="tags-cloud-8">python</a> <a href="/tags/qt/" style="font-size: 10px;" class="tags-cloud-0">qt</a> <a href="/tags/recommends/" style="font-size: 10px;" class="tags-cloud-0">recommends</a> <a href="/tags/review/" style="font-size: 16px;" class="tags-cloud-6">review</a> <a href="/tags/sql/" style="font-size: 19px;" class="tags-cloud-9">sql</a> <a href="/tags/srtp/" style="font-size: 10px;" class="tags-cloud-0">srtp</a> <a href="/tags/test/" style="font-size: 10px;" class="tags-cloud-0">test</a>
    </div>
  </div>
</section>
    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
      
        
      
        
      
        
      
        
          <a href="https://github.com/sterne012" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
          </a>
        
      
        
          <a href="https://twitter.com/sterne012" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-twitter" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M962.285714 233.142857q-38.285714 56-92.571429 95.428571 0.571429 8 0.571429 24 0 74.285714-21.714286 148.285714t-66 142-105.428571 120.285714-147.428571 83.428571-184.571429 31.142857q-154.857143 0-283.428571-82.857143 20 2.285714 44.571429 2.285714 128.571429 0 229.142857-78.857143-60-1.142857-107.428571-36.857143t-65.142857-91.142857q18.857143 2.857143 34.857143 2.857143 24.571429 0 48.571429-6.285714-64-13.142857-106-63.714286t-42-117.428571l0-2.285714q38.857143 21.714286 83.428571 23.428571-37.714286-25.142857-60-65.714286t-22.285714-88q0-50.285714 25.142857-93.142857 69.142857 85.142857 168.285714 136.285714t212.285714 56.857143q-4.571429-21.714286-4.571429-42.285714 0-76.571429 54-130.571429t130.571429-54q80 0 134.857143 58.285714 62.285714-12 117.142857-44.571429-21.142857 65.714286-81.142857 101.714286 53.142857-5.714286 106.285714-28.571429z"></path>
</svg>
          </a>
        
      
    </div>
     
    <p>&copy; 2022 <a href="/" target="_blank">sterne</a></p>

    

    <p>Powered by <a href="https://hexo.io" target="_blank" rel="noopener noreferrer">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank" rel="noopener noreferrer author">flex-block</a></p>

    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>
  </div>
</footer>
  </div>

  <div class="back-to-top-fixed soft-size--round soft-style--box">
    <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
      <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
      <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
    </svg>
  </div>

  
  <!-- aplayer -->


<!-- dplayer -->




  


  


  




<script src="/js/script.js"></script>


  
  <!-- 尾部用户自定义相关内容 -->
</body>
</html>